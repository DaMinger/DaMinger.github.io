<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[对MySQL关于order by+limit理解的一个误区]]></title>
    <url>%2F2017%2F12%2F11%2Fmysql-orderby%2F</url>
    <content type="text"><![CDATA[今天业务碰到一个线上问题,业务order by字段shopcode，用limit m,n做分页，希望按照shopcode排序获取所有的数据，但是遍历完一遍，发现有的数据没有获取到。挺奇怪的，于是做了个实验，复现了情景。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677mysql&gt; show create table shop;+-------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+| Table | Create Table |+-------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+| shop | CREATE TABLE `shop` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(10) COLLATE utf8mb4_unicode_ci NOT NULL DEFAULT &apos;&apos;, `shopcode` int(11) NOT NULL DEFAULT &apos;0&apos;, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci |+-------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+1 row in set (0.00 sec)mysql&gt; insert into shop(name,shopcode) values(&apos;a&apos;,10),(&apos;b&apos;,10),(&apos;c&apos;,10),(&apos;d&apos;,10),(&apos;e&apos;,10),(&apos;f&apos;,10),(&apos;g&apos;,10),(&apos;h&apos;,10),(&apos;i&apos;,10),(&apos;j&apos;,10);Query OK, 10 rows affected (0.00 sec)Records: 10 Duplicates: 0 Warnings: 0mysql&gt; select * from shop;+----+------+----------+| id | name | shopcode |+----+------+----------+| 1 | a | 10 || 2 | b | 10 || 3 | c | 10 || 4 | d | 10 || 5 | e | 10 || 6 | f | 10 || 7 | g | 10 || 8 | h | 10 || 9 | i | 10 || 10 | j | 10 |+----+------+----------+10 rows in set (0.00 sec)mysql&gt; select * from shop order by shopcode limit 0,2;+----+------+----------+| id | name | shopcode |+----+------+----------+| 10 | j | 10 || 2 | b | 10 |+----+------+----------+2 rows in set (0.09 sec)mysql&gt; select * from shop order by shopcode limit 2,2;+----+------+----------+| id | name | shopcode |+----+------+----------+| 3 | c | 10 || 4 | d | 10 |+----+------+----------+2 rows in set (0.00 sec)mysql&gt; select * from shop order by shopcode limit 4,2;+----+------+----------+| id | name | shopcode |+----+------+----------+| 5 | e | 10 || 6 | f | 10 |+----+------+----------+2 rows in set (0.00 sec)mysql&gt; select * from shop order by shopcode limit 6,2;+----+------+----------+| id | name | shopcode |+----+------+----------+| 7 | g | 10 || 8 | h | 10 |+----+------+----------+2 rows in set (0.00 sec)mysql&gt; select * from shop order by shopcode limit 8,2;+----+------+----------+| id | name | shopcode |+----+------+----------+| 2 | b | 10 || 10 | j | 10 |+----+------+----------+2 rows in set (0.00 sec) 我们发现 limit 0,2和limit 8,2的结果是一样的，看来原先对order by的理解有问题， 原来以为是先对shopcode整体排好序，再取对应分页的数据，查了下官方文档： 1234If you combine LIMIT row_count with ORDER BY, MySQL stops sorting as soon as it has found the first row_count rows of the sorted result, rather than sorting the entire result. If ordering is done by using an index, this is very fast. If a filesort must be done, all rows that match the query without the LIMIT clause are selected, and most or all of them are sorted, before the first row_count are found. After the initial rows have been found, MySQL does not sort any remainder of the result set. 上面官方文档里面有提到如果你将Limit row_count与order by混用，mysql会找到排序的row_count行后立马返回，而不是排序整个查询结果再返回。 为什么分页会不准呢？ 12If multiple rows have identical values in the ORDER BY columns, the server is free to return those rows in any order, and may do so differently depending on the overall execution plan.In other words, the sort order of those rows is nondeterministic with respect to the nonordered columns. 如果order by的字段有多个行都有相同的值，mysql是会随机的顺序返回查询结果的，具体依赖对应的执行计划。 那这种情况应该怎么解决呢？ 12If it is important to ensure the same row order with and without LIMIT, include additional columns in the ORDER BY clause to make the order deterministic. For example, if id values are unique, you can make rows for a given category value appear in id order by sorting like this: 如果想在Limit存在或不存在的情况下，都保证排序结果相同，可以额外加一个排序条件。例如id字段是唯一的，可以考虑在排序字段中额外加个id排序去确保顺序稳定。 如果SQL改成 select * from shop order by shopcode,id limit M,N。遍历去取数据妥妥没问题了。 官方文档：https://dev.mysql.com/doc/refman/5.6/en/limit-optimization.html]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>orderby</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL字符集备注]]></title>
    <url>%2F2017%2F12%2F10%2Fmysql-charset%2F</url>
    <content type="text"><![CDATA[字符集知识备注 12345678910111213141516171819202122查看数据库支持的字符集和校对规则show charset;或者 show character set;show collation;查看数据库当前的字符集和校对规则show variables like &apos;%character%&apos;;show variables like &apos;%collation%&apos;;查看表的校对规则 show table status from db_name like &apos;%table_name%&apos; ; 查看列的校对规则show full columns from table_name;更改表级别的字符集和字符校验规则ALTER TABLE tbl_name CONVERT TO CHARACTER SET charset_name COLLATE collation_name;为具体的某个字段指定其字符集和校验规则ALTER TABLE tbl_name MODIFY col_name &#123;CHAR | VARCHAR | TEXT&#125; (col_length) [CHARACTER SET charset_name] [COLLATE collation_name]例子ALTER TABLE customer_1 MODIFY name varchar(160) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL DEFAULT &apos;&apos;; 注意 12345678910111213字段属性的字符校对规则不一致，连表的时候有可能会报错，因为线上有些RD 会这样建表，CREATE TABLE `customer_1` ( `id` int(11) NOT NULL, `name` varchar(160) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NOT NULL DEFAULT &apos;&apos;, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE utf8mb4_general_ci表的字符校验规则是utf8mb4_general_ci，某些字段校验规则是utf8mb4_bin连表的时候有可能报错[HY000][1267] Illegal mix of collations (utf8mb4_unicode_ci,IMPLICIT) and (utf8mb4_general_ci,IMPLICIT) for operation &apos;=&apos;另外如果对字符集校验规则不同的字段还建立了索引，连表的时候，这个索引可能走不到。]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[replace操作导致主从auto_increment不一致]]></title>
    <url>%2F2017%2F12%2F03%2Fmysql-replace-autoincrement-inconsistent%2F</url>
    <content type="text"><![CDATA[周二做了个主从切换，然后半夜被RD打电话叫起来，说插入主键报重复主键错误，我登录到机器上一看，表中的最大主键ID确实大于表的auto_increment值，临时处理了下，先恢复业务，那为什么会出现这种情况？第二天和RD沟通后，他们业务中有replace操作，我怀疑这个操作会导致主从auto_increment不一致。 试验：构造表结构和数据 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152master:mysql&gt; CREATE TABLE `t` ( -&gt; `id` int(11) NOT NULL AUTO_INCREMENT, -&gt; `age` int(11) DEFAULT NULL, -&gt; `msg` varchar(10) DEFAULT NULL, -&gt; PRIMARY KEY (`id`), -&gt; UNIQUE KEY `uniq_age` (`age`) -&gt; ) ENGINE=InnoDB DEFAULT CHARSET=utf8;Query OK, 0 rows affected (0.30 sec)mysql&gt; insert into t (age, msg) values (1,&apos;aaa&apos;),(2,&apos;bbb&apos;),(3,&apos;ccc&apos;);Query OK, 3 rows affected (0.01 sec)Records: 3 Duplicates: 0 Warnings: 0mysql&gt; select * from t;+----+------+------+| id | age | msg |+----+------+------+| 1 | 1 | aaa || 2 | 2 | bbb || 3 | 3 | ccc |+----+------+------+3 rows in set (0.00 sec)mysql&gt; show create table t;+-------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+| Table | Create Table |+-------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+| t | CREATE TABLE `t` ( `id` int(11) NOT NULL AUTO_INCREMENT, `age` int(11) DEFAULT NULL, `msg` varchar(10) DEFAULT NULL, PRIMARY KEY (`id`), UNIQUE KEY `uniq_age` (`age`)) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8 |+-------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+1 row in set (0.00 sec)slave:mysql&gt; show create table t;+-------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+| Table | Create Table |+-------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+| t | CREATE TABLE `t` ( `id` int(11) NOT NULL AUTO_INCREMENT, `age` int(11) DEFAULT NULL, `msg` varchar(10) DEFAULT NULL, PRIMARY KEY (`id`), UNIQUE KEY `uniq_age` (`age`)) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8 |+-------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+1 row in set (0.03 sec) 进行replace操作 123456789101112131415161718192021222324252627master:mysql&gt; replace into t (age, msg) values (1, &apos;111&apos;);Query OK, 2 rows affected (0.00 sec)mysql&gt; select * from t;+----+------+------+| id | age | msg |+----+------+------+| 2 | 2 | bbb || 3 | 3 | ccc || 4 | 1 | 111 |+----+------+------+3 rows in set (0.00 sec)mysql&gt; show create table t;+-------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+| Table | Create Table |+-------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+| t | CREATE TABLE `t` ( `id` int(11) NOT NULL AUTO_INCREMENT, `age` int(11) DEFAULT NULL, `msg` varchar(10) DEFAULT NULL, PRIMARY KEY (`id`), UNIQUE KEY `uniq_age` (`age`)) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8 |+-------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+1 row in set (0.00 sec) 我们看到replace操作，有2行被影响，auto_increment自动+1，网上查资料得知：对于已经存在的数据，replace操作相当于进行update操作，而update实际是delete+insert两个连续操作，insert会导致auto_incement+1,但是binlog只会产生一条update语句。 12345678910111213141516171819202122binlog记录：确实只有一条update#171203 16:54:34 server id 114133006 end_log_pos 779912805 Table_map: `test`.`t` mapped to number 138# at 779912805#171203 16:54:34 server id 114133006 end_log_pos 779912863 Update_rows: table id 138 flags: STMT_END_FBINLOG &apos;yrsjWhMOiM0GLAAAAGWGfC4AAIoAAAAAAAEABHRlc3QAAXQAAwMDDwIeAAY=yrsjWh8OiM0GOgAAAJ+GfC4AAIoAAAAAAAEAAgAD///4AQAAAAEAAAADYWFh+AQAAAABAAAAAzExMQ==&apos;/*!*/;### UPDATE `test`.`t`### WHERE### @1=1 /* INT meta=0 nullable=0 is_null=0 */### @2=1 /* INT meta=0 nullable=1 is_null=0 */### @3=&apos;aaa&apos; /* VARSTRING(30) meta=30 nullable=1 is_null=0 */### SET### @1=4 /* INT meta=0 nullable=0 is_null=0 */### @2=1 /* INT meta=0 nullable=1 is_null=0 */### @3=&apos;111&apos; /* VARSTRING(30) meta=30 nullable=1 is_null=0 */# at 779912863#171203 16:54:34 server id 114133006 end_log_pos 779912890 Xid = 9277304COMMIT/*!*/; 1234567891011121314slave:从库只会接受到update的binlog,auto_increment不会加+1mysql&gt; show create table t;+-------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+| Table | Create Table |+-------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+| t | CREATE TABLE `t` ( `id` int(11) NOT NULL AUTO_INCREMENT, `age` int(11) DEFAULT NULL, `msg` varchar(10) DEFAULT NULL, PRIMARY KEY (`id`), UNIQUE KEY `uniq_age` (`age`)) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8 |+-------+----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+1 row in set (0.00 sec) 至此主从auto_increment的不一致的原因已经定位到。 隐患点：主从切换后，业务如有replace操作，可能造成新主库写入失败。 如何解决? 先了解下算法：MySQL对于auto_increment的算法是select max(id)+1 from t的方法来拿到auto_inrement的值。 淘宝的分享解释： 12345建表时可以指定 AUTO_INCREMENT值，不指定时默认为1，这个值表示当前自增列的起始值大小，如果新插入的数据没有指定自增列的值，那么自增列的值即为这个起始值。对于InnoDB表，这个值没有持久到文件中,而是存在内存中（dict_table_struct.autoinc）。那么又问，既然这个值没有持久下来，为什么我们每次插入新的值后， show create table t1看到AUTO_INCREMENT值是跟随变化的。其实show create table t1是直接从dict_table_struct.autoinc取得的（ha_innobase::update_create_info）。 解决办法 重启从库，所有表的auto_increment会修正。 插入新数据后，自增值自动追平，主库replace后如果有insert语句，这样会自动追平的。 延伸 insert into .. on duplicate key update语句 碰到表中已经存在要replace的数据，也会导致主从auto_increment不一致]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>replace</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书笔记【原则】]]></title>
    <url>%2F2017%2F11%2F25%2Fbook-%E5%8E%9F%E5%88%99%2F</url>
    <content type="text"><![CDATA[最近读到一本被洗脑的书籍，叫做《原则》，作者是美国对冲基金教父雷.达里奥，他提出一系列原则，并不断的实践=》反思=》更新自我=》实践，形成闭环，帮助自己在生活、事业、家庭等方面取得巨大的成功。 干货太多，我摘录部分对我触动比较大的地方。 首先要学会质疑，在消化每条原则时，作者请读者做到以下这条：…ask yourself: “Is it true?” 什么是原则？价值观是你认为重要的、“有价值”的东西，而在生活中若想顺从自己的价值观，我们需要的就是原则。原则连接价值观与行动，它如指引行动的灯塔，帮你成功应对现实生活中的条条框框。当面临两难抉择之时，遵循原则就能迎刃而解。如果没有原则，那么当你面临抉择之时，你将变得非常被动，因为你不知道自己最珍视什么，面对选择也无从下手。如此一来，就更别谈实现人生价值了。 你的处事原则会决定你的行为标准，当你同他人初识时，你们各自恪守的原则将会决定你们的互动模式，若你们的价值观与原则能够达到共享，大家就相处愉快，否则在相处中就会面临持续不断的误解和冲突。人与人的关系中，人们所秉持的原则大都模糊不清。 来自自身经历与反思的原则最有价值。每当面临两难抉择之际，我们会扪心自问，反复琢磨，在这样的过程中完善我们的原则。如果你有这样一个原则，“我绝不会偷东西”，那当你面对偷或不偷的选择时，就会适用这一原则。然而如果想要使选择的过程更加高效，那么每一项原则就必须与个人的价值观一致。为了满足这种一致性，就不得不再问问自己：为什么不偷？不偷的理由是因为同情潜在的受害者吗？还是因为害怕被抓？只有问过了这些问题，我们才能更深入地了解自己。原则在不断发展中，会和我们的核心价值观越来越一致。想要成功，就必须做出正确的、艰难的选择。你必须要有壮士断腕的勇气，个人处事如此，在领导一个团队时，也是如此。如果想要成为一个成功的领导者，就必须谨记，选择需是本着对团队成员的理解和关心做出的，而不仅仅是为了顺应他们。 It isn’t easy for me to be confident that my opinions are right.（坚信自己的观点都是对的可不是件容易的事情，这是个两面性的事情，你的观点对了，要经受住质疑，你的观点本身是错的话，会很可悲） Bad opinions can be very costly.（某些情况下犯错成本是极高的） The consensus is often wrong, so I have to be an independent thinker（独立思考，不要受大部分的人的思维干扰） I worked for what I wanted, not for what others wanted me to do（这点基于现实还是有点难的，但是在自己掌控的时间里，可以做到） I came up with the best independent opinions I could muster to get what I wanted. I stress-tested my opinions by having the smartest people I could find challenge them so I could find out where I was wrong（找更优秀的人，压测自己的观点和方案，跳出思维局限） I remained wary about being overconfident, and I figured out how to effectively deal with my not knowing.（我不敢太过自信，而是想办法有效处理我所不知道的事情，其实就是做事情把控制风险） I wrestled with my realities, reflected on the consequences of my decisions, and learned and improved from this process. （我同现实展开斗争，反思所做决定带来的后果，从中学习与提高） Truth — more precisely, an accurate understanding of reality — is the essential foundation for producing good outcomes. （真相：具体来说，就是精准理解现实 —— 这是达成良好结果的最重要根基。） The most important quality that differentiates successful people from unsuccessful people is our capacity to learn and adapt to these things. （区分成功人士与平庸之辈最重要的品质就是学习能力和适应能力。不能做到终身学习和思考，很快被这个时代所淘汰，真心感受，要跳出自我设限） As I mentioned before, I believe that life consists of an enormous number of choices that come at us and that each decision we make has consequences, so the quality of our lives depends on the quality ofthe decisions we make.（选择的质量决定的我们的生活） Reality + Dreams + Determination = A Successful Life （至今我还没搞清楚我的梦想是啥？） Pain + Reflection = Progress （痛苦加反思才有可能进步） In summary, I believe that you can probably get what you want out of life if you can suspend your ego and take a no-excuses approach to achieving your goals with open -mindedness, determination, and courage, especially if you rely on the help of people who are strong in areas that you are weak. （我认为要实现梦想，你得清除自我设障，做事不找借口、思维开放、下定决心、富有勇气，尤其要依靠那些在你不擅长的领域表现优秀之人。） In summary, I don’t believe that limited abilities are an insurmountable barrier to achieving yourgoals, if you do the other things right. （我不认为有限的能力是实现目标不可逾越的障碍，能把其他的事情做好，也能弥补自身的缺陷。） The biggest mistake most people make is to not see themselves and others objectively. If theycould just get around this, they could live up to their potentials. （很多人最大的错误就是没能客观看待自己或他人，克服了这点就能实现自身潜力的发展。）]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>个人成长</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL time_stamp字段基本用法]]></title>
    <url>%2F2017%2F11%2F18%2Fmysql-timestamp%2F</url>
    <content type="text"><![CDATA[MySQL版本mysql5.6.36,测试了解time_stamp的基本用法 1.timestamp类型允许一个表里可以有多列字段拥有自动插入时间和自动更新时间,更新其他列的时候，带有ON UPDATE CURRENT_TIMESTAMP的字段都会更新时间 123456789101112131415161718192021222324252627282930313233343536373839404142mysql&gt; CREATE TABLE time_test ( -&gt; id int(11), -&gt; time_1 timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, -&gt; time_2 timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP -&gt; ) ENGINE=InnoDB DEFAULT CHARSET=utf8;Query OK, 0 rows affected (0.31 sec)mysql&gt; show create table time_test;+-----------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+| Table | Create Table |+-----------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+| time_test | CREATE TABLE `time_test` ( `id` int(11) DEFAULT NULL, `time_1` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, `time_2` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP) ENGINE=InnoDB DEFAULT CHARSET=utf8 |+-----------+-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+1 row in set (0.00 sec)mysql&gt; insert time_test(id) values (1);Query OK, 1 row affected (0.00 sec)mysql&gt; select * from time_test;+------+---------------------+---------------------+| id | time_1 | time_2 |+------+---------------------+---------------------+| 1 | 2017-11-14 17:44:49 | 2017-11-14 17:44:49 |+------+---------------------+---------------------+1 row in set (0.01 sec)mysql&gt; update time_test set id =2 where id=1;Query OK, 1 row affected (0.05 sec)Rows matched: 1 Changed: 1 Warnings: 0mysql&gt; select * from time_test;+------+---------------------+---------------------+| id | time_1 | time_2 |+------+---------------------+---------------------+| 2 | 2017-11-14 17:45:20 | 2017-11-14 17:45:20 |+------+---------------------+---------------------+1 row in set (0.00 sec) 2.允许一列字段有自动插入时间属性，另一列字段只有自动更新时间属性，但是会默认赋予DEFAULT ‘0000-00-00 00:00:00’，更新其他列的时候，带有自动更新时间属性的字段会被更新 123456789101112131415161718192021222324252627282930313233343536373839404142434445mysql&gt; CREATE TABLE time_test_3 ( -&gt; id int(11), -&gt; time_1 timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP, -&gt; time_2 timestamp NOT NULL ON UPDATE CURRENT_TIMESTAMP -&gt; ) ENGINE=InnoDB DEFAULT CHARSET=utf8;Query OK, 0 rows affected (0.08 sec)mysql&gt; show create table time_test_3;+-------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+| Table | Create Table |+-------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+| time_test_3 | CREATE TABLE `time_test_3` ( `id` int(11) DEFAULT NULL, `time_1` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP, `time_2` timestamp NOT NULL DEFAULT &apos;0000-00-00 00:00:00&apos; ON UPDATE CURRENT_TIMESTAMP) ENGINE=InnoDB DEFAULT CHARSET=utf8 |+-------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+1 row in set (0.01 sec)mysql&gt; insert time_test_3(id) values(1),(2);Query OK, 2 rows affected (0.01 sec)Records: 2 Duplicates: 0 Warnings: 0mysql&gt; select * from time_test_3;+------+---------------------+---------------------+| id | time_1 | time_2 |+------+---------------------+---------------------+| 1 | 2017-11-14 17:53:43 | 0000-00-00 00:00:00 || 2 | 2017-11-14 17:53:43 | 0000-00-00 00:00:00 |+------+---------------------+---------------------+2 rows in set (0.00 sec)mysql&gt; update time_test_3 set id=3 where id =2;Query OK, 1 row affected (0.01 sec)Rows matched: 1 Changed: 1 Warnings: 0mysql&gt; select * from time_test_3;+------+---------------------+---------------------+| id | time_1 | time_2 |+------+---------------------+---------------------+| 1 | 2017-11-14 17:53:43 | 0000-00-00 00:00:00 || 3 | 2017-11-14 17:53:43 | 2017-11-14 17:54:44 |+------+---------------------+---------------------+2 rows in set (0.00 sec) 3.为多个字段指定timestamp字段，但不显示指明属性，会为第一个timestamp字段设置属性DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP，剩余timestamp字段设置 DEFAULT ‘0000-00-00 00:00:00’属性 123456789101112131415mysql&gt; CREATE TABLE `time_test2`(id int,time_1 timestamp,time_2 timestamp);Query OK, 0 rows affected (0.07 sec)mysql&gt; show create table time_test2;+------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+| Table | Create Table |+------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+| time_test2 | CREATE TABLE `time_test2` ( `id` int(11) DEFAULT NULL, `time_1` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, `time_2` timestamp NOT NULL DEFAULT &apos;0000-00-00 00:00:00&apos;) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci |+------------+------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+1 row in set (0.01 sec)]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>time_stamp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis_分析集群中key的内存情况]]></title>
    <url>%2F2017%2F11%2F15%2Fredis-analyze-memory%2F</url>
    <content type="text"><![CDATA[Redis集群内存暴增，需要下集群中哪类key占用内存比较多，简述下我的思路和操作步骤 1.去找个slave,bgsave一下，生成rdb文件 2.使用rdb工具分析rdb文件生成csv文件 rdb -c memory redis6379.rdb --bytes 0 -f memory.csv 查看下csv文件 cat memory.csv database,type,key,size_in_bytes,encoding,num_elements,len_largest_element 0,string,ops.073a7ae3d0fec21cd13c7a34d497cb70,304,string,210,210 0,string,test12,48,string,8,8 0,string,ops.5c8b7a27fd1597ef3202e9e4906cb630,304,string,194,194 0,hash,bach-price-dev.2ssku_inventory_price_100016002,5651,ziplist,323,9 0,set,monitor_device_list,83588,hashtable,920,37 0,string,ops.e58ccdb5730ae3dbdbcb7103747b228b,304,string,194,194 0,string,test4,48,string,8,8 0,string,ops.8bf1f83967a11fffb7ed55ac1f42fa10,304,string,213,213 0,string,test17,48,string,8,8 把第一行数据表头去了，方便导入MySQL分析 3.创建MySQL统计表 创建统计表 create table memory_count( id int primary key auto_increment, db int not null default 0 , key_type varchar(20) not null, key_name varchar(200) not null, key_size_in_bytes bigint not null, key_encoding varchar(20) not null, key_num_elements bigint not null, key_len_largest_element bigint not null); 123456789101112show create table memory_count;memory_count | CREATE TABLE `memory_count` ( `id` int(11) NOT NULL AUTO_INCREMENT, `db` int(11) NOT NULL DEFAULT &apos;0&apos;, `key_type` varchar(20) COLLATE utf8mb4_unicode_ci NOT NULL, `key_name` varchar(200) COLLATE utf8mb4_unicode_ci NOT NULL, `key_size_in_bytes` bigint(20) NOT NULL, `key_encoding` varchar(20) COLLATE utf8mb4_unicode_ci NOT NULL, `key_num_elements` bigint(20) NOT NULL, `key_len_largest_element` bigint(20) NOT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci 4.导入到MySQL 1234567891011121314把文件移动到这个变量路径下SHOW VARIABLES LIKE &quot;secure_file_priv&quot;; load语句LOAD DATA INFILE &apos;/var/lib/mysql-files/memory.csv&apos; INTO TABLE memory_countFIELDS TERMINATED BY &apos;,&apos; OPTIONALLY ENCLOSED BY &apos;&quot;&apos; ESCAPED BY &apos;&quot;&apos; LINES TERMINATED BY &apos;\n&apos;(db,key_type,key_name,key_size_in_bytes,key_encoding,key_num_elements,key_len_largest_element)到了MySQL里面，可以随便定制SQL统计语句了select left(key_name, 20),sum(key_size_in_bytes) from memory_count group by left(key_name, 20) order by sum(key_size_in_bytes) desc;]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于Falcon的ES监控]]></title>
    <url>%2F2017%2F11%2F12%2Felk-es-monitor-falcon%2F</url>
    <content type="text"><![CDATA[基于Falcon,写了个小程序，上报数据，做ES监控 希望有帮助，大家根据实际情况可以自定义修改。 代码地址：https://github.com/DaMinger/elasticsearch_monitor_falcon 集群级别 主要监控项 描述 es.cluster.health.active_primary_shards 集群内所有索引的主分片总数 es.cluster.health.active_shards_percent_as_number 可用分片百分比 es.cluster.health.alive es是否能连接上 es.cluster.health.delayed_unassigned_shards 延时待分配到具体节点上的分片数 es.cluster.health.initializing_shards 正在初始化的分片数 es.cluster.health.number_of_data_nodes 数据节点个数 es.cluster.health.number_of_nodes 节点总个数 es.cluster.health.number_of_pending_tasks 等待中任务的个数 es.cluster.health.relocating_shards 正在迁移中的分片数 es.cluster.health.status 集群健康状态 es.cluster.health.task_max_waiting_in_queue_millis 任务在队列中等待的最长时间 es.cluster.health.unassigned_shards 未分配到具体节点上的分片数 节点级别 主要监控项 描述 es.node.indices.flush.flush_latency 每次flush操作的平均响应时间 es.node.indices.indexing.index_current 当前indexing操作的个数 es.node.indices.indexing.indexing_latency 每次indexing操作的平均响应时间 es.node.indices.refreshing.refresh_latency 每次refreshing操作的平均响应时间 es.node.indices.search.fetch_current 当前fetch操作的个数 es.node.indices.search.fetch_latency 每次fetch操作的平均响应时间 es.node.indices.search.query_current 当前query操作的个数 es.node.indices.search.query_latency 每次query操作的平均响应时间 es.node.jvm.gc.collectors.heap_committed_in_bytes Amount of JVM heap committed es.node.jvm.gc.collectors.old.collection_count old gc 发生的次数 es.node.jvm.gc.collectors.old.collection_time_latency 每次old gc 时间 es.node.jvm.gc.collectors.young.collection_count young gc 发生的次数 es.node.jvm.gc.collectors.young.collection_time_latency 每次young gc的时间 es.node.jvm.mem.heap_used_percent jvm heap使用内存的百分比 es.node.thread_pool.bulk.queue 在队列里面的bulk操作个数 es.node.thread_pool.bulk.rejected 拒绝掉的bulk操作个数 es.node.thread_pool.force_merge.queue 在队列里面的force_merge操作个数 es.node.thread_pool.force_merge.rejected 拒绝掉的force_merge操作个数 es.node.thread_pool.index.queue 在队列里面的index操作个数 es.node.thread_pool.index.rejected 拒绝掉的index操作个数 es.node.thread_pool.search.queue 在队列里面的search操作个数 es.node.thread_pool.search.rejected 拒绝掉的search操作个数]]></content>
      <categories>
        <category>ELK</category>
      </categories>
      <tags>
        <tag>ELK</tag>
        <tag>ElasticSearch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL更改数据目录]]></title>
    <url>%2F2017%2F11%2F08%2Fmysql-change-datadir%2F</url>
    <content type="text"><![CDATA[今天工作中收到数据库报警，报磁盘空间90%多了，我一看4T的盘呢，怎么会报磁盘空间报警呢？再仔细一看，之前的运维人员把MySQL部署在了根目录上，隐形的坑，临时清理了日志，联系业务，需要把数据库迁移到数据盘上。 步骤 路由掉从库流量，先从库后主库。 1.关闭监控 2.备份原有的MySQL配置文件 3.关闭mysql mysqladmin -uXXXX -p’XXXX’ -S XXXX.sock shutdown 4.更改配置文件，对datadir、slow_query_log_file、log-error的三个参数更改目录 /data/${mysqldir}=&gt;/data1/${mysqldir} 5.mv MySQL目录到数据盘/data1/ mv /data/${mysqldir} /data1/${mysqldir} 6.赋权 chown -R mysql:mysql /data1/${mysqldir} 7.启动 /usr/bin/mysqld_safe –defaults-file=/etc/XXXX.cnf &gt;/dev/null &amp; 8.检查MySQL状态，打开报警 9.监控模板微调，磁盘报警需要改成监控的/data1磁盘情况 如果减少copy时间，注意清理slowlog和binlog]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何安装ES的IK插件]]></title>
    <url>%2F2017%2F11%2F05%2Felk-install-es-ik%2F</url>
    <content type="text"><![CDATA[本文主要介绍如何安装ES的IK插件，IK插件主要做分词用的，尤其对中文分词支持友好。 ES日志系统线上版本是5.5.1，IK地址：https://github.com/medcl/elasticsearch-analysis-ik 1.以ES的用户为每个节点安装插件 5.5.1以上版本官方已经支持命令安装，5.5.1以下版本需要mvn打包安装（如果觉得mvn打包麻烦，可以在plugins目录下创建ik目录，下载ZIP包，解压到该文件夹中,赋予正确权限也能行） 1./bin/elasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v5.5.1/elasticsearch-analysis-ik-5.5.1.zip 2.先暂停集群的shard自动均衡 123456curl -XPUT http://YOURHOST:9200/_cluster/settings -d&apos;&#123;&quot;transient&quot; : &#123;&quot;cluster.routing.allocation.enable&quot; : &quot;none&quot;&#125;&#125;&apos; 3.shutdown你要重启的节点 4.重启该节点，并确认该节点重新加入到了集群中 5.重启启动集群的shard均衡 123456curl -XPUT http://YOURHOST:9200/_cluster/settings -d&apos;&#123;&quot;transient&quot; : &#123;&quot;cluster.routing.allocation.enable&quot; : &quot;all&quot;&#125;&#125;&apos; 6.重复2-5步，重启其它节点。]]></content>
      <categories>
        <category>ELK</category>
      </categories>
      <tags>
        <tag>ELK</tag>
        <tag>IK插件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL的Load data的权限误区]]></title>
    <url>%2F2017%2F11%2F01%2Fmysql-loaddata%2F</url>
    <content type="text"><![CDATA[今天刚到公司，手机接到主从延时的报警，登录线上机器，发现是一条load data语句导致的。 1234567891011121314151617181920212223242526272829load data LOW_PRIORITY local infile &apos;/data/tmp/job-temp/app_ordering_system_maiev_check_reference_data_20171031&apos; replace into table order_check fields terminated by &apos;\t&apos; ( order_date,batch_code,transport_num,shop_code,shop_name,mid_classify_code,mid_classify_name,sku_main_code,sku_code,sku_name,sku_type,whether_new,whether_popular,sale_level,booking_spec,yesterday_stock,refer_abandon_amount,sale_amount_day,order_amount_day,expiration,whether_yummy,purchasing_unit_price,shop_start_date,shop_state,shop_business_state,picking_type,booking_qty,shop_type) 延迟原因很清晰明了，但是我看了下这个库不是数据组的业务，按理说不应该有load data权限，我找到账号，show grants一下，确实只有增删改查权限，找对应RD也确认了下，确实刚才使用这个账号执行了这个语句，线上数据库版本是MySQL Community 5.6.36，我在测试环境上也能够复现这个情景。原先我以为load data权限怎么也得有file权限，看来存在误区。 上网搜了搜，看到这段解释解决了我的疑问 123456789- load data infile into table table_name ; 执行命令的用户有权限访问的文件，然后load到DB中,并且需要file权限。 - load data local infile into table table_name ; 只要是客户端用户有权限访问的文件，都可以上传到服务端，然后load到DB中，这样是特别危险的。 注意：此时的load data不需要file权限！- select * from t into outfile &apos;filename&apos;; 先看运行mysqld的用户有没有对存放文件的目录有写权限，再看执行命令的用户有没有file权限. 解决办法，针对load data local infile,扫描线上MySQL参数local_infile的值，设置成OFF即可。 反思 对看有疑惑的问题，一定要先记录下来，想办法去解决，不断走出自己的知识误区。]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
        <tag>Load data</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ELK_ElasticSearch5.5.1版本快速部署]]></title>
    <url>%2F2017%2F10%2F29%2Felk-how-to-install-es%2F</url>
    <content type="text"><![CDATA[进入新公司，接触了一段时间ELK组件，挺有意思的，记录下学习过程。这篇主要介绍下ElasticSearch的部署过程，版本是5.5.1，ElasticSearch社区非常活跃，2017年从5.1迭代到6.X，大家一定多参考ES的官方文档，非常详细，中文参考书籍《ELK Stack 权威指南》第二版 饶琛琳 著，这本书对于新手很有帮助。 背景本文主要描述如何快速部署ES三节点，多节点步骤部署和本文一样，这里我规划的节点属性是默认的属性，每个节点即是master节点，也是data节点，大规模集群的时候，这个属性建议分开，后面我写文章讲下我所理解的ES架构。安装步骤中涉及的IP，我统一用YOURHOSTIP替代了。有疑问直接EMAIL我。 安装步骤安装JDK1234567891011121314151617181920212223242526271. java -version 如果发现有openjdk 或者其他非官方版的Java，卸载掉rpm -qa|grep javarpm -e --nodeps rpmpackage 2.下载java rpm包ES官方推荐the Oracle JDK version 1.8.0_131，Oracle官方已经GA到1.8.0_144，下载最新的JDK即可 3.安装# rpm -ivh jdk-8u144-linux-x64.rpmPreparing... ################################# [100%]Updating / installing... 1:jdk1.8.0_144-2000:1.8.0_144-fcs ################################# [100%]Unpacking JAR files... tools.jar... plugin.jar... javaws.jar... deploy.jar... rt.jar... jsse.jar... charsets.jar... localedata.jar...# java -versionjava version &quot;1.8.0_144&quot;Java(TM) SE Runtime Environment (build 1.8.0_144-b01)Java HotSpot(TM) 64-Bit Server VM (build 25.144-b01, mixed mode)成功显示即可 Linux 参数调整官方文档：https://www.elastic.co/guide/en/elasticsearch/reference/current/system-config.html 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748491.关闭selinux状态/usr/sbin/sestatus -v 显示disable如果不是disable状态，临时关闭setenforce 0永久关闭 (需要重启机器)修改/etc/selinux/config 文件将SELINUX=enforcing改为SELINUX=disabled 2.关闭iptablessystemctl status firewalld.service 显示disable如果不是disable状态，临时关闭systemctl stop firewalld.service #停止firewallsystemctl disable firewalld.service #禁止firewall开机启动 3.文件描述符cat /etc/security/limits.conf 若是发现soft nofile和hard nofile 小于65536，设置一下ulimit -n 65536echo -ne &quot;* soft nofile 65536* hard nofile 65536&quot; &gt;&gt;/etc/security/limits.conf 4.SSD机器修改IO调度算法为noop或者deadline首先找到对应的盘，替换掉下面的sdacat /sys/block/sda/queue/schedulernoop deadline [cfq]（默认是cfq）echo &quot;noop&quot; &gt;/sys/block/sda/queue/schedulercat /sys/block/sda/queue/scheduler[noop] deadline cfq (变为noop) 5.系统线程限制echo -ne &quot;* soft nproc 2048* hard nproc 4096&quot; &gt;&gt;/etc/security/limits.conf 6.Virtual memory修改系统限制一个进程可以拥有的VMA(虚拟内存区域)的数量sysctl -w vm.max_map_count=262144sysctl -a | grep &quot;vm.max_map_count&quot;若无参数请增加vim /etc/sysctl.confvm.max_map_count = 262144 7.关闭swap分区swapoff -a设置降低交换分区的使用优先级vim /etc/sysctl.confvm.swappiness = 0 安装部署ES1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677781.下载安装ES5.5.1curl -L -O &quot;https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-5.5.1.tar.gz&quot;tar -xvf elasticsearch-5.5.1.tar.gzcp -r elasticsearch-5.5.1 /data/mv elasticsearch-5.5.1 es012.创建es用户组及es用户groupadd esuseradd es -g eschown -R es:es es013.es启动前 jvm配置vim /data/es01/config/jvm.options-Xms16g-Xmx16g注：按需调整，配置物理机内存的50%，但不要超过31G。4.es启动前 修改elasticsearch.ymlvim /data/es01/config/elasticsearch.yml#集群名称 保持唯一cluster.name: ESTEST#节点名称node.name: es_test01#数据路径path.data: /data/es01/esdata#监听地址network.host: 0.0.0.0#防止脑裂 集群主节点数/2+1discovery.zen.minimum_master_nodes: 2#单播ES节点地址. 这里可以添加集群的任一一个或者多个节点discovery.zen.ping.unicast.hosts: [&quot;YOURHOSTIP&quot;]5.复制copy其他节点并编辑# cp -r es01 es02# cp -r es01 es03# chown -R es:es es02/# chown -R es:es es03/只需要更改es02的elasticsearch.yml#节点名称#node.name: es_test02#数据路径path.data: /data/es02/esdata只需要更改es03的elasticsearch.yml#节点名称#node.name: es_test03#数据路径path.data: /data/es03/esdata6.用es用户以此启动./es01/bin/elasticsearch -d./es02/bin/elasticsearch -d./es03/bin/elasticsearch -d查看/data/es01/logs、/data/es02/logs、/data/es03/logs的ESTEST.log 查看启动是否成功[2017-08-15T21:40:03,881][INFO ][o.e.n.Node ] [ESTEST01] starting ...[2017-08-15T21:40:04,036][INFO ][o.e.t.TransportService ] [ESTEST01] publish_address &#123;YOURHOSTIP:9300&#125;, bound_addresses &#123;0.0.0.0:9300&#125;[2017-08-15T21:40:04,047][INFO ][o.e.b.BootstrapChecks ] [ESTEST01] bound or publishing to a non-loopback or non-link-local address, enforcing bootstrap checks[2017-08-15T21:40:07,113][WARN ][o.e.d.z.ZenDiscovery ] [ESTEST01] not enough master nodes discovered during pinging (found [[Candidate&#123;node=&#123;ESTEST01&#125;&#123;YpiDg9KHSuW0POdZpQ1Uqg&#125;&#123;ogEGQGNTRDKCiNubSVPbAQ&#125;&#123;YOURHOSTIP&#125;&#123;YOURHOSTIP:9300&#125;, clusterStateVersion=-1&#125;]], but needed [2]), pinging again[2017-08-15T21:40:11,239][INFO ][o.e.c.s.ClusterService ] [ESTEST01] detected_master &#123;ESTEST02&#125;&#123;Py8YVQGZQf-M1PApgWJ9eg&#125;&#123;RohcDroPS5mpCLAJ01gR9w&#125;&#123;YOURHOSTIP&#125;&#123;YOURHOSTIP:9301&#125;, added &#123;&#123;ESTEST02&#125;&#123;Py8YVQGZQf-M1PApgWJ9eg&#125;&#123;RohcDroPS5mpCLAJ01gR9w&#125;&#123;YOURHOSTIP&#125;&#123;YOURHOSTIP:9301&#125;,&#125;, reason: zen-disco-receive(from master [master &#123;ESTEST02&#125;&#123;Py8YVQGZQf-M1PApgWJ9eg&#125;&#123;RohcDroPS5mpCLAJ01gR9w&#125;&#123;YOURHOSTIP&#125;&#123;YOURHOSTIP:9301&#125; committed version [1]])[2017-08-15T21:40:11,278][INFO ][o.e.h.n.Netty4HttpServerTransport] [ESTEST01] publish_address &#123;YOURHOSTIP:9200&#125;, bound_addresses &#123;0.0.0.0:9200&#125;[2017-08-15T21:40:11,278][INFO ][o.e.n.Node ] [ESTEST01] started观察到started就ok了7.查看状态查看集群状态curl -XGET &apos;http://localhost:9200/_cat/health?v&apos;看到status 为Green就是健康的 epoch timestamp cluster status node.total node.data shards pri relo init unassign pending_tasks max_task_wait_time active_shards_percent1503041882 15:38:02 ESTEST green 3 3 0 0 0 0 0 0 - 100.0%查看节点状态curl -XGET &apos;http://localhost:9200/_cat/nodes?v&apos;ip heap.percent ram.percent cpu load_1m load_5m load_15m node.role master nameYOURHOSTIP（你机器的IP） 37 83 7 0.31 0.63 0.80 mdi - es_test02YOURHOSTIP（你机器的IP） 48 83 7 0.31 0.63 0.80 mdi - es_test03YOURHOSTIP（你机器的IP） 37 83 6 0.31 0.63 0.80 mdi * es_test01]]></content>
      <categories>
        <category>ELK</category>
      </categories>
      <tags>
        <tag>ELK</tag>
        <tag>ElasticSearch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Inception_备份测试]]></title>
    <url>%2F2017%2F10%2F25%2Finception-backup%2F</url>
    <content type="text"><![CDATA[Inception的亮点是支持语句的备份，方便回滚，这篇文章主要测试它的备份功能 备份参数1234inception_remote_backup_host //远程备份库的hostinception_remote_backup_port //远程备份库的portinception_remote_system_user //远程备份库的一个用户inception_remote_system_password //上面用户的密码 这些参数可以直接在命令行中指定，也可以用–defaults-file指定一个my.cnf文件，一经指定，再不能更改，除非将服务器关闭，修改之后再次启动。 注意项 Inception是默认开备份功能的 执行时被影响的表如果没有主键的话，就不会做备份了，这样更简单并且备份时间及数据都会少一点，不然回滚语句的WHERE条件就会将所有列写进去，这样会影响性能且没有太大意义，所以在WHERE条件中，只需要主键即可 Inception备份用户必须要具备下面的权限才能成功备份的，包括：CREATE、INSERT。CREATE权限用于创建表或者库的，INSERT权限用于插入备份数据的，其它的权限不需要 备份机器的库名组成是由线上机器的IP地址的点换成下划线，再加上端口号，再加上库名三部分，这三部分也是通过下划线连接起来的。 备份库中的表与线上表的列不同，它是用来存储所有对这个表修改的回滚语句的 rollback_statement text 这个列存储的是针对当前这个表的某一行被修改后，生成的这行修改的回滚语句。因为binlog是ROW模式的，所以不管是什么语句，产生的回滚语句都是针对一行的，同时有可能一条语句的修改影响了多行，那么这里就会有多个回滚语句，但对应的是同一个 SQL 语句。对应关于通过下面的列来关联起来。 opid_time varchar(50) 这个列存储的是的被执行的 SQL 语句在执行时的一个序列号，这个序列号由三部分组成： timestamp(int 值，是语句被执行的时间点) 线上服务器执行时所产生的 thread_id 当前这条语句在所有被执行的语句块中的一个序号产生结果类似下面的样子：1413347135_136_3，针对同一个语句影响多行的情况，那么所产生的多行数据中，这个列的值都是相同的，这样就可以找到一条语句对应的所有被影响数据的回滚语句 测试表带有自增主键表结构和数据 insert插入一行数据 insert into test(col2,col3,col4) values (1,1,1); 下图这个sequence 非常重要 查看回滚语句 插入多行数据 insert into test(col2,col3,col4) values (1,1,1),(2,2,2),(3,3,3),(4,4,4),(5,5,5) 查看回滚语句 delete删除多条记录 delete from test where col2=2 and col3=1 and col4=6; 查看回滚语句 update更新多条记录 update test set col4=8 where col4=6 查看回滚语句 alter也支持alter的回滚，但是对于备份来说意义不大，测试两种 alter table test add col5 int not null default 10 comment “test”; 回滚语句 alter table test drop col5; 回滚语句 表带有主键，但不自增表结构 insert插入一行数据 insert into test5(col2,col3,col4) values(1,1,1),注意下面warning，没有指定主键，但是还是备份和执行成功了。默认id为0 回滚语句 插入多行数据 insert into test5(id,col2,col3,col4) values(1,1,2,3),(2,1,2,3),(3,1,2,3) 回滚语句 deletedelete from test5 where id&gt;=7 回滚语句 updateupdate test5 set col2=2 where id not in (10) 回滚语句 alter和上面一致回滚结果一致 表没有主键表结构 insertinsert test6(id,col2,col3,col4) values(1,1,1,1),(1,2,1,1),(1,1,1,4),(1,1,3,1);尽管提示备份成功了，但实际没有备份 没有备份 updateupdate test6 set col3=6 where id=1 没有备份 deletedelete from test6 where id=1 没有备份 表带有联合主键创建联合主键表 insertinsert into test (col2,col3,col4) values (1,1,1),(2,2,2),(3,3,3),(2,3,4); 回滚语句 updateupdate test set col4=4 where id in (2,3,4); 回滚语句 deletedelete from test where id in (2,3,4); 回滚语句]]></content>
      <categories>
        <category>MySQLTools</category>
      </categories>
      <tags>
        <tag>Inception</tag>
        <tag>表变更平台</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Inception_OSC测试]]></title>
    <url>%2F2017%2F10%2F22%2Finception-osctest%2F</url>
    <content type="text"><![CDATA[这篇文章主要介绍Inception对OSC工具的支持，如果对OSC工具不熟悉，可以自行先Google下 我这里配置的OSC配置文件 123456789101112131415161718192021222324######inception的osc设置#######指定pt-online-schema-change脚本的位置inception_osc_bin_dir=/usr/bin/pt-online-schema-change#对应OSC参数--recursion-methodinception_osc_recursion_method=processlist#对应OSC参数--[no]drop-old-tableinception_osc_drop_old_table=1#对应OSC参数--[no]check-replication-filtersinception_osc_check_replication_filters=1#对应OSC参数--check-intervalinception_osc_check_interval=5#对应OSC参数--max-laginception_osc_max_lag=1#对应OSC参数--chunk-timeinception_osc_chunk_time=0.05#对应OSC参数--max-load中的Threads_connected部分inception_osc_max_thread_connected=1300#对应OSC参数--max-load中的Threads_running部分inception_osc_max_thread_running=64#这个参数实际上是一个OSC的开关，如果设置为0，则全部ALTER语句都走OSC，如果设置为非0，则当这个表占用空间大小大于这个值时才使用OSC方式。单位为M，inception_osc_min_table_size=16#一个全局的OSC开关，默认是打开的inception_osc_on=1#无法支持--set-vars --tries 测试过程生成一张表，数据量100W 1sysbench /usr/share/sysbench/oltp_read_write.lua --mysql-host=xxx --mysql-port=xxx --mysql-db=test --mysql-user=admin --mysql-password=xxx --tables=1 --table-size=1000000 --report-interval=10 --threads=10 --time=300 --db-driver=mysql prepare 你在python脚本中，改下参数–enable-check，先进行审核，得到改表语句的一个hash值，方便后面查看改表进度 查看改表进度inception get osc_percent ‘*0521D6C1E73C8F3B82809CF9D5D43D1D68095674’;或者使用inception get osc processlist; 终止改表inception stop alter ‘*0521D6C1E73C8F3B82809CF9D5D43D1D68095674’; 再次改表，如果发现有触发器没有删干净，会报错退出 特殊说明 如果你kill掉了python脚本，OSC工具在后台依旧在执行，需要手动kill掉，清理触发器和临时表。]]></content>
      <categories>
        <category>MySQLTools</category>
      </categories>
      <tags>
        <tag>Inception</tag>
        <tag>表变更平台</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Inception_基本功能测试]]></title>
    <url>%2F2017%2F10%2F21%2Finception-basictest%2F</url>
    <content type="text"><![CDATA[进行Inception基本功能测试，尽量覆盖测试场景，后面再讲OSC改表测试 根据文档，需要配置了一份适合当前环境的配置文件，配置文件中备份用户和密码需要自己配置。 inception配置文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127[inception]######inception基本设置#######MySQL原生参数,设置inception程序打开全日志general_log=ON#MySQL原生参数，定义inception程序的全日志位置general_log_file=/data/w/inception/data/inception.log#MySQL原生参数,定义inception的端口port=6669#MySQL原生参数,定义inception的socketsocket=/tmp/inc.socket#MySQL原生参数,跳过mysql程序起动时的字符参数设置,使用服务器端字符集设置character-set-client-handshake=OFF#MySQL原生参数,设置默认的服务器端字符集character-set-server=utf8mb4#设置当前Inception服务器是不是只读的，这是为了防止一些人具有修改权限的帐号时，通过Inception误修改一些数据，如果inception_read_only设置为ON，则即使开了enable-execute，同时又有执行权限，也不会去执行，审核完成即返回inception_read_only=OFF#打开与关闭Inception对SQL语句中各种名字的检查，如果设置为ON，则如果发现名字中存在除数字、字母、下划线之外的字符时，会报Identifier &quot;invalidname&quot; is invalid, valid options: [a-z,A-Z,0-9,_]inception_check_identifier=ON#inception的统计功能,设置是不是支持统计Inception执行过的语句中，各种语句分别占多大比例，如果打开这个参数，则每次执行的情况都会在备份数据库实例中的inception库的statistic表中以一条记录存储这次操作的统计情况，每次操作对应一条记录，这条记录中含有的信息是各种类型的语句执行次数情况inception_enable_sql_statistic=ON######inception的语法校验#######检查insert语句的列属性，insert table (xx,xx..) values(xx,xx..)inception_check_insert_field=ON#在DML语句中没有WHERE条件时，报错inception_check_dml_where=ON#在DML语句中使用了LIMIT时，报错 inception_check_dml_limit=ON#在DML语句中使用了Order By时，报错inception_check_dml_orderby=ON#Select * 时，报错inception_enable_select_star=ON#order by rand时，报错inception_enable_orderby_rand=ON#创建或者新增列时如果列为NULL，报错inception_enable_nullable=OFF#不支持外键inception_enable_foreign_key=OFF#一个索引中，列的最大个数，超过这个数目则报错（可设置1-64）inception_max_key_parts=5#在一个修改语句中，预计影响的最大行数，超过这个数就报错inception_max_update_rows=5000#一个表中，最大的索引数目，超过这个数则报错（1-1024）inception_max_keys=16#建表指定的存储引擎不为Innodb，报错inception_enable_not_innodb=ON#表示在建表或者建库时支持的字符集inception_support_charset=utf8mb4#建表时，表没有注释时报错inception_check_table_comment=ON#建表时，列没有注释时报错inception_check_column_comment=ON#建表时，如果没有主键，则报错inception_check_primary_key=ON#不支持分区表inception_enable_partition_table=OFF#不支持enum,set,bit数据类型inception_enable_enum_set_bit=OFF#检查索引名字前缀是否为&quot;idx_&quot;，检查唯一索引前缀是不是&quot;uniq_&quot;，不是的话，报错inception_check_index_prefix=ON#自增列为无符号型inception_enable_autoincrement_unsigned=ON#当char类型的长度大于这个值时，就提示将其转换为VARCHARinception_max_char_length=16#当建表时自增列的值指定的不为1，则报错inception_check_autoincrement_init_value=ON#当建表时自增列的类型不为int或者bigint时报错inception_check_autoincrement_datatype=ON#建表时，如果没有为timestamp类型指定默认值，则报错inception_check_timestamp_default=ON#不允许自己设置列的字符集inception_enable_column_charset=OFF#建表时，如果指定的自增列的名字不为ID，则报错，说明是有意义的，给提示inception_check_autoincrement_name=ON#在多个改同一个表的语句出现是，报错，提示合成一个inception_merge_alter_table=ON#检查在建表、修改列、新增列时，新的列属性要有默认值inception_check_column_default_value=ON#检查支持BLOB字段，包括建表、修改列、新增列操作inception_enable_blob_type=ON#检查在SQL语句中，是不是有标识符被写成MySQL的关键字，默认值为不允许。inception_enable_identifer_keyword=OFF######inception备份设置（可动态在连接命令中传入）#######远程备份库的hostinception_remote_backup_host=YOURHOST#远程备份库的portinception_remote_backup_port=YOURPORT#远程备份库的一个用户inception_remote_system_user=YOURUSER#用户的密码inception_remote_system_password=YOUREPASWORD######inception的osc设置#######指定pt-online-schema-change脚本的位置inception_osc_bin_dir=/usr/bin/#对应OSC参数--recursion-methodinception_osc_recursion_method=processlist#对应OSC参数--[no]drop-old-tableinception_osc_drop_old_table=1#对应OSC参数--[no]check-replication-filtersinception_osc_check_replication_filters=1#对应OSC参数--check-intervalinception_osc_check_interval=5#对应OSC参数--max-laginception_osc_max_lag=1#对应OSC参数--chunk-timeinception_osc_chunk_time=0.05#对应OSC参数--max-load中的Threads_connected部分inception_osc_max_thread_connected=1300#对应OSC参数--max-load中的Threads_running部分inception_osc_max_thread_running=64#这个参数实际上是一个OSC的开关，如果设置为0，则全部ALTER语句都走OSC，如果设置为非0，则当这个表占用空间大小大于这个值时才使用OSC方式。单位为M，inception_osc_min_table_size=16#一个全局的OSC开关，默认是打开的inception_osc_on=1#无法支持--set-vars######权限认证#######MySQL原生参数，因为Incpetion没有权限验证过程，那么为了实现更安全的访问，可以给Inception服务器的这个参数设置某台机器（Inception上层的应用程序）不地址，这样其它非法程序是不可访问的，那么再加上Inception执行的选项中的用户名密码，对MySQL就更加安全#bind_address=*#这个用户名在配置之后，在连接Inception的选项中可以不指定user，这样线上数据库的用户名及密码就可以不暴露了，可以做为临时使用的一种方式，但这个用户现在只能是用来审核，也就是说，即使在选项中指定--enable-execute，也不能执行，这个是只能用来审核的帐号。#inception_user=&apos;&apos;#与上面的参数是一对，这个参数对应的是选项中的password，设置这个参数之后，可以在选项中不指定password#inception_password=&apos;&apos; 测试表SQL,用官方文档的test.py改改，开始基本功能测试 123456789101112131415161718192021222324252627282930313233create table liuqinming_test(\id int unsigned not null auto_increment comment &quot;test&quot;,\a varchar(100) not null default &quot;a&quot; comment &quot;a&quot;,\b int not null default 0 comment &quot;b&quot;,\addtime timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP comment &quot;time&quot;,\c int not null default 0 comment &quot;c&quot;,\d int not null default 0 comment &quot;d&quot;,\e int not null default 0 comment &quot;e&quot;,\f int not null default 0 comment &quot;f&quot;,\g int not null default 0 comment &quot;g&quot;,\h int not null default 0 comment &quot;h&quot;,\i int not null default 0 comment &quot;i&quot;,\j int not null default 0 comment &quot;j&quot;,\k int not null default 0 comment &quot;k&quot;,\l int not null default 0 comment &quot;l&quot;,\m int not null default 0 comment &quot;m&quot;,\n int not null default 0 comment &quot;n&quot;,\o int not null default 0 comment &quot;o&quot;,\p int not null default 0 comment &quot;p&quot;,\primary key(id),\index idx_a(a),\index idx_c(c),\index idx_d(d),\index idx_e(e),\index idx_h(h),\index idx_i(i),\index idx_j(j),\index idx_k(k),\index idx_l(l),\index idx_m(m),\index idx_n(n),\index idx_o(o,a,e,f,g)\)engine = innodb default charset utf8mb4 comment &quot;liuqinming_test&quot;;\ 建表规则针对下面的建表要求进行逐一测试，不通过的error信息记录下来。 规则 errormessage 存储引擎必须为innodb Execute: Unknown storage engine ‘mysiam’ 建表支持的字符集必须为utf8mb4 Set charset to one of ‘utf8mb4’ for table ‘liuqinming_test’. 表没有注释时报错 Set comments for table ‘liuqinming_test’. 列没有注释时报错 Column ‘b’ in table ‘liuqinming_test’ have no comments. 如果没有主键，则报错 Set a primary key for table ‘liuqinming_test’.Incorrect table definition; there can be only one auto column and it must be defined as a key. 不支持enum,set,bit数据类型 Not supported data type on field: ‘status’. 不允许存在MySQL的关键字 Identifier ‘status’ is keyword in MySQL. 列属性要有默认值 Set Default value for column ‘status’ in table ‘liuqinming_test’ 列默认值为NULL，报错 Column ‘a’ in table ‘liuqinming_test’ is not allowed to been nullable. 自增列为无符号型 Set unsigned attribute on auto increment column in table ‘liuqinming_test’ 自增列的名字不为id,则报错 Auto increment column ‘tid’ is meaningful? it’s dangerous! 自增列的值指定的不为1，则报错 Set auto-increment initialize value to 1. 自增列的类型不为int或者bigint时报错 Set auto-increment data type to int or bigint. 当char类型的长度大于16时，提示将其转换为VARCHAR Set column ‘a’ to VARCHAR type. 检查索引名字前缀是否为”idx“，检查唯一索引前缀是不是”uniq“，不是的话，报错 Index ‘idxx_a’ in table ‘liuqinmingtest’ need ‘idx‘ prefix.Index ‘uniqx_b’ in table ‘liuqinmingtest’ need ‘uniq‘ prefix. timestamp类型要指定默认值 Set default value for timestamp column ‘addtime’.Set Default value for column ‘addtime’ in table ‘liuqinming_test’ 一个表中，最大的索引数目为16个 Too many keys specified in table ‘liuqinming_test’, max 16 keys allowed. 一个索引中，列的最大个数为5个 Too many key parts in Key ‘idx_o’ in table ‘liuqinming_test’ specified, max 5 parts allowed. 不支持外键 Foreign key is not allowed in table ‘liuqinming_test’. 不支持分区表 Unknown error 1289 插入 插入语句必须是insert into table (xx,xx..) values(xx,xx..),挂上列属性 支持多条insert的插入语句 insert into tableA (xx,xx..) values(xx,xx..)；insert into tableA (xx,xx..) values(xx,xx..)；…. 不支持replace操作执行过程中的违反规则的一些其他错误信息 规则 errormessage 检查insert语句的列属性 Set the field list for insert statements 如果指定列属性个数和指定value个数不相等，报错 Column count doesn’t match value count at row 1 删除 delete语句必须带有where条件,支持in的语法 支持多条delete语句，delete from test where id=1;delete from test where id=2;….执行过程中的违反规则的一些其他错误信息 规则 errormessage 必须带有where条件 set the where condition for select statement. 查询 不支持select查询 改表 测试通过支持所有alter标准语法 删除列 增加列 （不能是null,必须要加默认值，必须有列注释） 修改列的类型信息 支持change和modify语法 添加索引 索引前缀必须为”idx_” 添加唯一限制条件索引 “uniq_” 删除索引 执行过程中的违反规则的一些其他错误信息 规则 errormessage 在多个改同一个表的语句出现是，报错，提示合成一个 Merge the alter statement for table ‘test’ to ONE. 增加的列已存在 Column ‘col4’ have existed. 删除的列不存在 Column ‘col5’ not existed 其他测试情况信息 规则 errormessage 表如果存在的话 Table ‘liuqinming_test’ already exists 在一个修改语句中，预计影响的最大行数，超过5000就报错 Update rows more then 5000. 在DML语句中使用了LIMIT时，报错 Limit is not allowed in update/delete statement 在DML语句中使用了Order By时，报错 Order by is not allowed in update/delete statement. order by rand时，报错]]></content>
      <categories>
        <category>MySQLTools</category>
      </categories>
      <tags>
        <tag>Inception</tag>
        <tag>表变更平台</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Inception_安装部署]]></title>
    <url>%2F2017%2F10%2F19%2Finception-install%2F</url>
    <content type="text"><![CDATA[背景公司现阶段还没有自助表变更平台，工作中一些DDL和DML还得手动搞，一是重复的事情反复做，时间消耗多，二是人工执行存在风险隐患，于是开始调研一下去哪儿的inception工具，如果可行，对它进行二次封装进行web化开发。 线上服务器Linux版本：Centos7 下载源码和安装相关依赖包从Github上下载源码 git clone https://github.com/mysql-inception/inception.git 安装必要的编译包 yum install -y openssl-devel gcc-c++ ncurses-devel cmake 注意bison包需要编译安装，下载bison：http://ftp.gnu.org/gnu/bison/ 版本最好是2.6之前的，最新的可能会有问题 wget http://ftp.gnu.org/gnu/bison/bison-2.6.tar.gz tar -zxvf bison-2.6.tar.gz cd bison-2.6 ./configure make make install 然后做个软连接 cd /usr/bin ln -s /data/bison-2.6/src/bison 查看bison版本号 bison -V 编译安装inception进入inception目录 sh inception_build.sh debug [linux] 上述命令中debug为编译安装的目录，[linux]为当前操作系统平台那么需要注意的是，每次如果出错之后，需要把编译目录删除掉，重新执行，不然会执行出错。 编辑配置文件inc.inf文件,这个配置文件在后面的文章详细讲解配置下 [inception] general_log=1 general_log_file=inception.log port=6669 socket=/tmp/inc.socket character-set-client-handshake=0 character-set-server=utf8 inception_remote_system_password=YOURBACKPASSWORD inception_remote_system_user=admin inception_remote_backup_port=33006 inception_remote_backup_host=YOURBACKUSER inception_support_charset=utf8mb4 inception_enable_nullable=0 inception_check_primary_key=1 inception_check_column_comment=1 inception_check_table_comment=1 inception_osc_min_table_size=1 inception_osc_bin_dir=/data/temp inception_osc_chunk_time=0.1 inception_enable_blob_type=1 inception_check_column_default_value=1 启动 ./inception/debug/mysql/bin/Inception --defaults-file=inc.inf 测试 mysql -uroot -h127.0.0.1 -P6669 inception get variables; 正常输出就OK 简单使用编写一个test.py,在test库里面创建一张表 #!/usr/bin/python #-*- coding: utf-8 -*- import MySQLdb sql=&apos;/*--user=YOURUSER;--password=YOURPASSWORD;--host=YOURHOST;--port=33006;--execute=1;*/\ inception_magic_start;\ use test;\ CREATE TABLE lqm_test(\ id int unsigned not null auto_increment comment &quot;aaaa&quot;,\ username varchar(10) not null default 0 comment &quot;xxx&quot;,\ primary key(id))\ engine = innodb default charset utf8mb4 comment &quot;dddd&quot;;\ inception_magic_commit;&apos; try: conn=MySQLdb.connect(host=&apos;127.0.0.1&apos;,user=&apos;root&apos;,passwd=&apos;&apos;,db=&apos;&apos;,port=6669) cursor=conn.cursor() cursor.execute(sql) results = cursor.fetchall() column_name_max_size=max(len(i[0]) for i in cursor.description) row_num=0 for result in results: row_num=row_num+1 print &apos;*&apos;.ljust(27,&apos;*&apos;),row_num,&apos;.row&apos;, &apos;*&apos;.ljust(27,&apos;*&apos;) row = map(lambda x, y: (x,y), (i[0] for i in cursor.description), result) for each_column in row: if each_column[0] != &apos;errormessage&apos;: print each_column[0].rjust(column_name_max_size),&quot;:&quot;,each_column[1] else: print each_column[0].rjust(column_name_max_size),&apos;:&apos;,each_column[1].replace(&apos;\n&apos;,&apos;\n&apos;.ljust(column_name_max_size+4)) cursor.close() conn.close() except MySQLdb.Error,e: print &quot;Mysql Error %d: %s&quot; % (e.args[0], e.args[1]) python test.py,观察log # less inception.log 171011 18:11:46 2 Query set autocommit=0 2 Query /*--user=XXX;--password=XXX;--host=XXX;--port=33006;--execute=1;*/inception_magic_start;use test;CREATE TABLE lqm_test(id int unsigned not null auto_increment comment &quot;aaaa&quot;,username varchar(10) not null default 0 comment &quot;xxx&quot;,primary key(id))engine = innodb default charset utf8mb4 comment &quot;dddd&quot;;inception_magic_commit 检查表是否创建成功即可]]></content>
      <categories>
        <category>MySQLTools</category>
      </categories>
      <tags>
        <tag>Inception</tag>
        <tag>表变更平台</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[由DBA和RD的日常沟通引起的反思]]></title>
    <url>%2F2017%2F10%2F15%2FRD-communicate-with-DBA%2F</url>
    <content type="text"><![CDATA[工作中务必会进行跨岗位的沟通，很多人会问如何进行高效沟通？不如逆向思考，不高效的沟通有哪些？下面例子看看大家躺枪几个。哈哈。 Eaxmple 1 RD: 在？（如果没有及时回答，或者不在电脑旁边之后就没有然后了） 一般人看到这信息时，根本不知道你要沟通什么？通常的判断是问题不重要，会放到不紧急不重要的类别处理。合理的留言可以从why,when,who,what,where 五W的角度加上信息属性，当对方看到信息之后会了解大致背景，然后再进行how和what的沟通处理。 Eaxmple 2 RD:我的数据库挂了/访问不了了 /…. DBA:？？？ 这种提问方式是比较常见的，其实也是最无效的。没有提供DBA足够的信息（数据库名称、ip端口、线上or线下、报错信息是啥？提问者提出的问题要满足一个闭环,也就是你发出问题之后,信息要足够充分不需要回答者多次询问，减少沟通链条过长导致解决问题的时间被拉长。 Eaxmple 3 RD: 在不在，咨询一个技术问题，给表删除字段这个SQL语句怎么写？ DBA: 。。。 关于技术问题，可以直接提问DBA，但是如果经过谷歌、百度搜索后，大部分能够解决简单类问题，而且能给你很多延伸的解决方案，如果通过搜索引擎还解决不了，最起码一些问题的信息背景你有了，再和DBA沟通也能减少信息交互。 Eaxmple 4 RD: 我在DBA平台为啥查不到这个库XX？ DBA: 我去看看。（去DB查询） DBA: 没找到你的库,回了张截图。 DEV: 不好意思,我搞错了，库名应该叫YY。 提供错误或者不准确的信息源，解决者通过错误的信息源解决问题，效果可想而知。 Eaxmple 5 RD: 在吗？请看看我这个工单，附上一张截图，我的任务还没执行？ DBA: 单击图片，查找工单id，去系统获取信息，把信息返回。 额。其实工单信息很详细，其实点一点鼠标就能知道走到哪步流程，即使没看，也不应该截图，直接把链接地址贴过去更好些，以免解决者再次获取查找信息。 DBA as a server，客户是上帝。每天要面对很多个开发的咨询或者提问。这时候要适当引导他们进行有效提问，有效的提问会极大的缩减彼此的沟通成本和提高解决问题效率。其实提问之前只要做到一点，就能搞定很多事情，就是换位思考，别人想要获取什么信息？我这样提问别人能否快速解决？我站在对方的角度，我看到这个问题，怎么回复？你慢慢试试这种思维，相信会有收获的。]]></content>
      <categories>
        <category>DBA日常</category>
      </categories>
      <tags>
        <tag>沟通技巧</tag>
        <tag>DBA</tag>
        <tag>反思</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[百度_工程师的六大意识]]></title>
    <url>%2F2017%2F10%2F14%2F%E4%B8%AA%E4%BA%BA%E6%88%90%E9%95%BF_%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%9A%84%E5%85%AD%E5%A4%A7%E6%84%8F%E8%AF%86%2F</url>
    <content type="text"><![CDATA[重读旧文，与大家共勉！ 六大意识是百度在数年前每个入职的工程师必被灌输的职场意识,若干年后更深以为然。 质量意识 流程意识 world class procedure：用流程解决具有共性的、重复性问题，提高效率 既有的流程应严格遵守；没有流程的应创建流程 要对自己的工作质量负责，不要期待别人来发现自己的问题 “稳定”压倒一切，线上服务最重要 用户体验最重要 工作安排：二八原则 优先解决线上服务稳定性问题 不要“想当然”： 不要默认“没问题”，而是缺省认为“有问题”；“肯定没问题”一定有问题 反复核实(double check)十分重要 “我以为他们已经开始做，但我也没有跟他们确认一下”—导致项目延期 “我以为这个接口是这样定义，但谁想到是那样的”—导致程序崩溃 “我以为发出邮件，他肯定就知道了”—实际上，他/她根本不在相应的邮件列表中 时间意识 目标管理、结果导向 弹性工作制：上下班时间自由支配 关键是要按时保质完成工作 只争朝夕，争分夺秒 激烈的产业竞争环境 不要拖到最后才开始工作，因为总可能会有意外 能今天做完的绝不拖到明天 自我管理，自我推动 每件事情都有完成时间表，给自己一个约束，给别人一个承诺 每件事情有始有终，设立一些里程碑，在里程碑上检查进度，主动向其他人通报进度 建立个人品牌，树立别人对自己的信心 沟通意识 平等沟通 在沟通上没有级别概念 不要碍于面子，不要怕犯错误：报喜亦报忧 CC文化 及时沟通： 邮件是最主要的沟通形式，但有时不是最有效的 当面沟通，电话沟通，召集会议都是有效的形式，但要留下文字 有效沟通 沟通要达到效果 如果没有效果，应让更多人知道，尤其是你的老板和对方的老板 团队意识 集体荣誉感： 用你的成绩为你的团队带来光荣 互相帮助，互相学习 乐于给别人提供帮助 也勇于向别人学习：有问题不要憋在肚子里 互相理解 把周围同事当作你的资源，包括你的经理 对事不对人，尊敬身边每一个人 求实意识 科学求实是技术发展的基础 用数字说话，用事实证明，不要有“想当然”的思想 大胆假设，小心求证，不放过每一个细节和疑点 客观公正 杜绝“可能”，“大概”，“应该”这样模棱两可的用词，而是用准确的数字和事实来论证 每个工作能用量化的指标来进行衡量 性能、容量、准确性、召回率、死链率，etc. 没有量化，就没有绩效 通过这些指标衡量自己的成长和进步 通过这些指标知道工作的方向和重点 进取意识 永葆激情，积极主动 热爱你所从事的工作 不要等别人为你分配任务，你就是自己的老板 与时俱进，不断学习 在高速成长的公司，你才会有高速成长的可能 要有和公司、团队的同步成长的意识 对技术、对质量的追求永无止境 没有最好，只有更好 目标远大，不固步自封，自我满足 忧患意识 Case study和自我总结，自我学习和提高 Case study是一种文化，从事故中吸取经验教训 容忍失败，但不容忍重复失败 经常反思一下自己 不放过任何一次问题，勇敢地剖析自己]]></content>
      <categories>
        <category>工作技能</category>
      </categories>
      <tags>
        <tag>个人成长</tag>
        <tag>工作技能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书笔记【炒股的智慧】]]></title>
    <url>%2F2017%2F10%2F10%2Fbook_%E7%82%92%E8%82%A1%E7%9A%84%E6%99%BA%E6%85%A7%2F</url>
    <content type="text"><![CDATA[我的股市入门启蒙书，这本书虽然很小很薄，但作者对股市乃至投机市场的认识深刻到位，不敢妄自评论，做下书摘。值得反复读，仔细寻味。 # 不管什么股票，买股之前，先看看250天的平均线。只买250天均线以上的股票，最好在股价从250天均线之下穿越到250天均线之上时买入。 进股后给个5%～8%的止损。 只要股价在250天均线之上，坐等！有时可能股价几年都不回到250天均线之下。一旦股价再碰到250天均线，卖掉！ 每手不要下超过本金的10%。 这些做法简单实用，若股友们愿照做，请记住别找不做的理由。规矩就是规矩，按既定方针办。股友们当然也可用200天、150天或300天均线；中心思想就是牛市时抓中间一段，熊市时避开。请大家记住，您永远不知股价会跌多低，您也不知股价会升多高。赚钱慢慢来，不要急！ # 我们看到股民好获小利，买进的股票升了一点，便迫不及待地脱手。这只股票或许有75%继续上升的机会，但为了避免25%什么都得不到的可能性，股民宁可少赚些。结果是可能有 5000元利润的机会，你只得到500元。任何炒过股的读者都明白，要用较出场价更高的价位重新入场是多么困难。股价一天比一天高，你只能做旁观者。而一旦买进的股票跌了，股民便死皮赖脸不肯止损，想像出各种各样的理由说服自己下跌只是暂的。其真正的原因只不过为了搏那 25%可能全身而退的机会！结果是小亏慢慢积累成大亏。 # 在股市中，买进的股票跌了，你就再多买一点，因为第二次买的价钱较上次为低，所以平均进价摊低了。从心理上，你的心态和赌场亏钱时一样。一方面你亏不起，另一方面你在报复股市，报复股市让你亏钱。同时内心希望，只要赢一手，就是连本带利全回来。因为平均进价摊低了，股票的小反弹就能提供你全身而退的机会。这样的心态是极其有害的。股票跌的时候通常有它跌的理由，常常下跌的股票会越跌越低。这样被套牢，你就越陷越深，直到你心理无法承受的地步。一个致命的大亏损，常常就彻底淘汰了一位股民。 # 炒股是很古老的行业，成功的先例非常多，这是不需要天才的行业。最重要的是锲而不舍的精神和战胜自己的勇气。可以这么说，识不识字和能否在股市成功没有必然的联系。当然，识字的总有那么点优势。 # 导致股价上涨的三因素。虽然引起股价增长的因素很多，但最重要的是盈利及盈利增长。(下面两段反映了市盈率的参考价值) 盈利的增长，市盈率当成股价是否偏宜的衡量标准。这种概念从根本上来说是对的，但在炒股上实用性不大。一个健康、发展迅速的公司，其盈利必定逐年增长。这个增长的速度越快越好。一个公司的盈利若能以每个25%的速度增长，那么三年就能将盈利翻一倍。盈利增长的速度必须建立在合理的数字上。去年每股赚了1分钱，今年2分钱，盈利增长了100%，但这个数字是没有意义的。如果公司的盈利从每股5角升到1元，这个100%的盈利增长定将使投资大众的眼睛发亮。 盈利增长的前提是销售收入的增长。一个公司的销售收入如果无法增长，盈利增长通常是玩会计游戏的结果，对这一点读者们要留意。另一必须留意的是销售收入增长的速度和盈利增长速度的关系。公司的营业额由1亿元升到2亿元，100%的增长率。但盈利只从5角升到6角，20%的增长。这时要好好调查一下为什么？是不是同类产品多了竞争者，公司只好削价求售？虽然营业额不错，但收益率却降低了！如果是这样的话，这只股票的升幅也就有限了。最使市场注目的盈利的加速增长。一个每年盈利增长25%的公司突然将增长速度提高到 40%，甚至50%,这通常铺好了股价成倍上翻的道路。 新产品，新产品并不局限于实物; ，可以是新的生意概念，新的推销手法，新的管理方式。 公司回购自身股票 # 朋友，你认为什么因素使投资者入市买股票？华尔街有过调查，使一般投资者入场买股票的原因最主要的就是因为股票在升！你明白了吗？一般投资者入场买股票主要不是因为股票的成本收益比率低或红利高，而是因为股票在升！升！升！除了股票在升的理由之外，其它因素都是次要的。这就是为什么股票一开始升势，它往上一波高过一波，不会马上停止。要想学习养成对股票运动的感觉，你必须牢牢记住这一点。 你能猜到为何一般投资人卖股票吗？读完上一段落，结论应该很明显。华尔街的调查证实了你的猜测：投资人卖股票的最主要原因是因为股票在跌！在跌！投资人卖股票不是因为成本收益比率高或其它原因，而是因为股票在跌。这就是为何跌势一开始，不会马上停止。现在你能体会到为什么股票升时常常升得离谱，跌时跌到惨不忍睹的原因了吧？记住股民买卖股票的真正原因，耐心地观察市场，你很快就会发现股票运动是有迹可循的。 # 支撑线和阻力线：一旦阻力线被突破，股票应该继续上升，虽然可能有反调，但即便反调也不应该跌到阻力线之下，否则便是不正常运动。同样，一旦支撑线被突破，股票应往下跌，否则的话，便是不正常运动。如果股票一跌破支撑线便反弹到支撑线之上，可能是买股的好时机。 双肩图和头肩图：和上述道理相同，一旦股价穿越突破点，它应能够继续，否则的话便可认为是不正常运动。 平均线：以两百天平均线为例，一个正常的升势，股价应在两百天平均线之上；一个正常的跌势，股价应在平均线之下波动。否则，都可以认为是不正常运动。必须强调，股市操纵可能改变每天的或短期的波动，但不可能改变大势。道氏理论特点指出这一点。 在蓄劲后期，爬坡初期，如果是开始一个真正的爬坡期，应有交易量增加的现象，股价一举突破阻力线。一旦进入爬坡期，股票开始升势，股票波动应具有”一波高过一波的现象。 虽然这并不绝对，但整个波动应该在两百天平均线之上。在这段时间，投资者们必须安坐如山，不要为股价的短线升跌吓出场，但要打起十二分精神注意危险信号。经过疲劳期，股价跌穿平均线及支撑线，便是离场的时候了。 # 我怎样看技术分析 由于我自己以中短期炒作为主，技术分析是我买进卖出的主要参考。简单地说，我主要靠这几个图吃饭。但对没有多少经验的炒手来讲，你想也靠这几个图吃饭可能没有这么容易。《华尔街日报》登过一则这样的故事：一位记者靠抛硬币在十字坐标上画线，硬币出正面就升一格，反面就降一格，抛了几十次硬币后就画出一条曲线。他把这条曲线交给一位著名的技术分析专家研究，说是一只股票的走势图，请教他的意见。该技术分析家看图后说该股票极具上升潜力，一定要知道这只股票的名称。记者如实相告，该技术分析家听后勃然大怒，拂袖而去。这位记者便据此写了一篇报道。你读了这则故事有什么感觉？就我看，这位技术分析家犯了个严重的错误，他没有问交易量到哪儿去了？ 不要把技术分析孤立起来看。研究股票的大市，研究公司的经营情况，研究公司的产品，再看股票的走势图，特别还要注重交易量的变化，只有在这个基础上，技术分析才有意义。最最重要的是记住止损。 这些图是死的，在实际操作中，你会碰到很多例外，只有通过实践你才知道怎么处理这些例外。这些图之所以重要，因为它提供了最好的临界点。 # 我怎样看股票的大市 炒股高手利物莫是这样强调股票大市的重要性的：炒股的诀窍便是在牛市中全力投入，在牛市结束或接近结束的时候卖掉你的所有股票。就我自己的经验，用技术分析的方法来判定大市的走向及走向的变动是最为有效的工具。研究股票指数图，把它看成一只股票，看看这只股票是处于什么运动阶段，它运动正常吗？留意每天的交易总量。如果股市交易总量很大，但指数不升，或开市走高，收市低收盘，这就给你危险信号了。留意一下周围发生了什么事？中央银行是否要调整利率？周边国家是否有动乱？大市的转变通常有一过程，它较单独股票转向来得慢。大市的转变可能需几天，也可能是几星期，重要的是感到危险的时候，你必须采取动作。同样，你要留意股市跌到底时所提供的信号。当股市跌了很多，跌到大家都失去信心的时候， 你会发现有一天股市狂升，可能升1%或2%，交易量很大，这往往是跌到底的信号，大户开始入场了。但这还不是进场的最佳时机，被下跌套牢的股民可能乘这个反弹卖股离场。如果在此之后，股票指数突破上一个波浪的最高点，你可以证实跌势基本结束，是进场的时候了。从图上看这时应有升势时具备的特点。 股市的运动不断重复，你要仔细研究过去的规律。拿份长期的综合指数走势图，研究过去发生的一切，随着时间的推移，你就能培养起对股票大市的感觉。判断大市走向是极其重要的。我发觉新手（我自己以前也是一样）用很多心思研究单独股票的基础层面和技术层面，认为再好的市场也有股票跌，再坏的市场也有股票升，所以忽视大市的走向。我要在这里强调：炒股是概率的游戏，逆大潮流而动，你的获胜概率就被大打折扣了。将大市和单独股票结合起来考虑，是专业炒手们必须培养的心态。虽然这有一个学习过程， 但一定要在心理上不断提醒自己：大市不好时，别买任何股票。 请记着：当街头巷尾的民众都在谈论股市如何容易赚钱的时候，大市往往已经到顶或接近到顶。人人都已将资金投入股市，股市继续升高的推动力就枯竭了。而大众恐惧的时候，则该卖的都已经卖了，股票的跌势也就差不多到头了。 判断股市大市还应注意下列几点 大的政治环境和经济环境有什么变动？今天的企业越来越具全球性，其它国家发生的政治经济危机将会影响本国的市场。近来东南亚发生的经济危机便是最好的例子。 本国的经济大势怎么样？通货膨胀的情形如何？外汇兑换率有无变动的可能？中央银行会调整利率吗？ 所谓的股市龙头有什么表现？在股市到顶之前，你会发现股市的龙头股在大市到顶之前的一段时间开始疲软。 垃圾股有什么表现？在股市到顶的前一段时间，一些平时没有人闻问的小股票开始变得活跃且向上升。龙头股的价格已贵到买不下手的地步，社会游资便开始涌向三四线股票。 每天收市的时候，有多少只升的股票？有多少只跌的股票？综合指数有时会被几只大股票糊弄。一只在综合指数占有大份额的股票偶尔会影响真正的方向。比如某天有 1/4 的股票跌，3/4 的股票升，但 1/4 的跌股中可能一只在综合指数占大份额的股票，如香港的汇丰银行，使得综合指数下跌。在这种情况下，综合指数不完全反映大市的真实走向。 考虑类别股。如金融股、电子股、房地产股等等。虽然大市的综合指数走升势，其中某些类别可能在走跌势。研究大市走向时，应将类别综合考虑。特别是有时大市的走势并不明显，但金融股可能处在升势，电子股却走跌势。炒手们应根据类别股的运动形态来决定具体某只股票的买卖。 # 德国有位炒家为股价和股值做过一个极好的例子：想象你外出遛狗：狗有时跑在前面，有时跑在后面；你拴狗的绳子也有时长，有时短，但无论如何，狗最终会跑回你身边。你就是价值，狗就是价格。体会一下这个例子，你会明白很多东西。太离谱的股价会出现，但通常不会维持很久。 # 成功的要素 通过你自己的观察和研究，不断积累经验，将自己每次入场获胜的概率从50%提高到60%，甚至70%；而且每次进场不要下注太大，应只是本金的小部分。这样长期下来，你就能久赌必赢。 任何对炒股有一定认识的人，都明白炒股所需的具体知识少得可怜。影响股票升落的因素就是这么多，真正重要的因素列出来占不满你的手指，甚至不识字的也可以在股市露一手。股票的引诱力也人所共知，如果做得好，前景**的光明。这样的行业，成功率甚至低过减肥！为什么？因为人们常常做不到自己知道该做的事情！ 在进入具体的买卖技巧的探讨之前，我希望读者们能明白在炒股这行成功必须有什么样的思考方式。你首先必须以保本为第一要务，在保本的基础上再考虑怎样赚钱。保本不是说保就能保得住的，除非你不涉足股市。只要你把资金投入股市，你就有亏本的可能。股票何时运动正常的概念非常重要，我在这里特地加了一段，你对股票何时运动正常完全没有概念的话，你的炒股无非是瞎猫碰死老鼠。学股之路是艰难且漫长的，要想从股票学校毕业，学股人必须有一定的素质。只有具备这些素质，你才可能熬过黑暗的时光，否则，成功只是幻想。你如果还不具备成功的投资者所具有的共性，希望你从今天开始培养。除了毅力之外，没有别的要求。 # 那么投机的原理是什么呢？它的精华可以浓缩成两句话：（1）败而不倒；（2）追求卓越。“败而不倒”和“追求卓越”八个字简单易记，股友们请放在肚子里慢慢琢磨，保证你每年都有新的体会。 # 保本 炒股是用钱赚钱的行业。一旦你的本金没有了，你就失业了。无论你明天见到多么好的机会，手头没有本金，你只能干着急。几乎所有的行家，他们对炒股的首要建议便是尽量保住你的本金。而做到保本的办法只有两个：一、快速止损；二、别一次下注太多。 炒过股票的朋友都有这样的经历：亏小钱时割点肉容易，亏大钱时割肉就十分困难。这是人性的自然反应。在一项投资上亏太多钱的话，对你的自信心会有极大的打击。你如果有一定的炒股经历，必然同时拥有赚钱和亏钱的经验。赚钱时你有什么感觉？通常你会在内心指责自己为什么开始的时候不多买一些，下次碰到“应该会赚大钱”的机会，你自然就会下大注。这是极其危险的。在炒股这一行，没有什么是百分之百的。如果第一手进货太多，一旦股票下跌，噩梦就开始了。每天下跌，你希望这是最后一天；有时小小的反弹，你就把它看成大起的前兆；很快这只股票可能跌得更低，你的心又往下沉。你将失去理性判断的能力。人性共通，我算是这些经历的过来人，其痛深切。 具体的做法就是分层下注。你如果预备买1000 股某只股票，第一手别买1000股，先买200 股试试，看看股票的运动是否符合你的预想，然后再决定下一步怎么做。如果不对，尽快止损。如果一切正常，再进400 股，结果又理想的话，买足1000股。由于股票的运动没有定规，你不入场就不可能赚钱，而入场就有可能亏钱，所以承担多少风险便成为每位炒手头痛的事。索罗斯在他的自传中提到，他对应承担多大风险最感头痛。解决这个问题并无任何捷径，只有靠你自己在实践中摸索对风险的承受力，不要超出这个界限。 然而什么是你对风险的承受力呢？最简单的方法就是问自己睡得好吗？如果你对某只股票担忧到睡不着，表示你承担了太大的风险。卖掉一部分股票，直到你觉得自己睡得好为止。把“保本”这个概念牢牢地记在心里，你在炒股时每次犯错，你的体会就会深一层，时间一久，你就知道该怎样做了。 # 不断盈利 读者或许会嘲笑这样的题目，炒股如果不是为了盈利，炒股干什么？难道吃饱了撑的不成？但你注意到“盈利”二字前是什么？是“不断”。在股票市场偶尔赚点钱不难，只要你运气好就可以了。难的是“不断”二字。要想在股市不断赚钱，除了知识和经验之外，就是必须忍耐，等待赚钱的时机。问问一般的股民，他们入市资金有多少买了股票？有多少是现金？你会很惊奇地发现，一般股民几乎把入市资金全部买了股票。不管是牛市还是熊市时，他们都是这样。这些人有一个共同的想法：“我的钱是用来赚钱的。”读者们若有机会到赌场看看，就明白股民们为什么会这样做。赌客们站在赌台旁，一注都不肯放过，生怕下一手就是自己赢钱的机会。直到输完才会收手。 你要明白一点：股市有时是完全无序的，你根本就不知股票下一步会怎样运动。股票在大多时是有理性，有规律的。虽然每只股票的个性都不一样，但大同小异，你需要不断研究，不断观察，等你的经验积累到一定地步，就知道怎样顺势而行。等待、忍耐、观察，只有在股票的运动符合你的入场条件时才入场。只有这样，你才能够确定你入场的获胜概率大过50%。在这基础上，不断盈利才有可能。当然，千万别忘了保本。 # 赚大钱 给读者出一道题：在你面前是两位炒手的交易记录。他们去年都翻了一倍，即100%的回报率。一位是常胜将军，他的交易全部赚钱，有卖必赚，虽然每次赚的都不多，但他的交易记录密密麻麻的一大叠，积少成多，他赚了100%。另一位似乎运气不怎么样，交易中亏的次数多，赚的次数少。但他亏时亏的钱少，赚时赚的钱多，特别是有只股票卖出价较买入价升了4 倍。算总账他也赚了100%。你怎么评价这两位股票炒手？两人中的一位是运气很好的新手，另一位可是资深的专业炒手。你现在大概能够猜到哪位是哪位了吧？ 从他们的交易记录，你体会到什么了吗？在现实生活中，专业炒手的记录几乎都如上面所描述，他们明白股票买卖不可能每次都正确，那么在错误的时候为何要付大的代价？但在他们正确的时候，他们试图从中得到最大的利润。可是新手们很少有这么好的运气，他们通常把赚钱的股票首先出手，满足于赚小钱，结果通常是手头有一大堆套牢的股票。想象你手里有1 万元，你告诉自己要分散风险，每只股票只投1/10，即1000 元，一年下来，五升五跌，五只股票跌了10%，四只升了10%，另外一只升了200%。那么一年下来，这1 万元变成12900 元，近30%的回报率。其中那只升了200%的股票是成功的决定性因素。 炒过股的朋友，你碰到过5元的股票升到15元吗？这样的机会多不多？但你抓到过多少？你是不是常常过早离场？使你过早离场的主要原因有两个：一、人好小便宜；二、不够经验判断股票运动是否正常。 所以我们看到新手赚钱时通常只赚小钱。话又说回来，如果你知道5 元的股票会升到15 元，你也绝不会提早离场的。问题是你不能确定。这便涉及股票运动是否正常的判定问题。具体的请参考第二章第二节中“股票的正常运动与周期性运动”一段。在这里我要强调的是：只要股票运动正常，便必须按兵不动。炒股高手利弗莫尔特别指明，他炒股的秘诀不是他怎样思考，而是他在买对了的时候能够安坐不动。这是很难的一件事，你要克服对脱手获利的冲动。 另一点要强调的是：如果你确定股票运动正常，你的胜算很大，这时你应该在这只股票上适当加大下注的比重。如果你的致胜概率是60%，你下10%的注，但经验告诉你这次的致胜概率是80%，你就应加注。从10%提高到30%甚至50%，从直觉上你能明白为什么应这么做。 # 提高获胜概率 炒股是亏钱容易赚钱难的行业。假设你手上有1万元资本，亏掉50%后剩下5000元。但你要回到1 万元，你必须赚100%，5000元要翻一倍才会回到1万元。任何有基本数学概念的人都知道100%的道路较50%来得漫长。股票当然更不例外。对炒股票而言，赌的次数很多。对这类赌，久赌常胜的关键之一便是下好注。 怎样下注是艺术，没有绝对的是非之分。但有门科学叫概率，它对怎样完善下注艺术提供了科学的参考。我以下用生活的例子而不是抽象的数学公式来引导大家思考。我们都知道抛硬币出现正面和反面的机会各是50%，即有一半的概率出正面，一半的概率出反面。假设你今天和一位朋友赌钱，抛硬币定胜负，出正面你赢1 元，出反面你输1元，你们各拿1000 元的本金来赌。这场赌博的结果很清楚，赌久了，谁也赢不了，谁都不会输。这是一场公平的游戏。 突然你朋友建议说：从下一手起，出正面你赢9角5分，出反面你还是给他1元。你还干吗？你当然不干，因为你知道被剃光头是迟早的事。反过来，朋友建议说出正面你赢1 元，出反面你赔9角5分。你会怎么想？你会大声吼叫：好！因为这时你知道剃他光头只是迟早的事，你知道你赢定了。 现在假设这位朋友要提高赌注，每注500 元，出正面你赢500 元，出反面你输475元。概率没有变，还是1:0.95，但赌注变了，从本金的1/1000 提高到1/2。这时你有什么感觉？你还是知道赢的机会大过亏的机会，但你赢定的感觉没有了。你的本金只够赌两回，你的手开始冒汗。如果这1000 元是你下个月的饭钱，你还敢赌吗？上面的例子，你输赢的概率没有变化，但下注的数额变了，整个游戏的性质便发生了变化，你从赢定了变成了没有赢的把握。朋友，你炒了几年股票，觉得自己有经验了，你知道你的经验是干什么用的吗？你的经验提高了你每次进场赢钱的概率！ 现在你应该明白在股市不断赚钱的秘诀了：通过你自己的观察和研究，不断累积经验，将自己每次入场获胜的概率从50%提高到60%，甚至70%；而且每次进场不要下注太大，应只是本金的小部分。这样长期下来，你就能“久赌必赢”。 数学的道理是很明白的。每次下注应占本金总额的多少，决定于你的经验及对风险的承受能力，没有死定的百分比。你要记住财不入急门。我这里给个建议：新手的话，把本金分成6~8 份，每次下其中一份。有了经验，慢慢地把份数减少。你如果有60%的胜算，下注的数额比你有80%的胜算时应该为少。至于你怎么知道有60%的胜算或80%的胜算，完全决定于你自己的经验。下注的数额和下注的时机也有密切的关系，怎样选择下注的时机将在第四章第一节另行讲述，希望读者结合起来看。 # 人性有很多缺陷。人希望股票会怎么运动，认定股票会怎么运动，当股票的运动和预想不符合时，就会认为股市错了，自己没有错。但炒友必须牢牢记住：股市从来都没错，它总是走自己要走的路，出错的只有你自己。你所能做的只有追随股市。见到危险信号，不要三心二意，不要存有幻想，把股票全部脱手。几天以后，也许一切又恢复正常，你一样可以重新入场。如果能这样做，你将发现你为自己省下了很多焦虑及学费。 华尔街流行的说法是这样的：你在铁路轨道上漫步，见到火车向你冲来，你应该怎么办？你自然应该闪开一边，待火车离去后，你随时还可以重上铁道继续漫步。迟疑不决会危及生命的。上述讲的是一个正常的股票升势所具有的特点。时间的跨度通常比较大，从几个月到几年都说不定。对一般的投资者，能抓住整个“势”的60%~70%就是相当不错的成绩。这也是一般投资者最需掌握的。把时间的跨度缩短，我们就回到了技术分析基本知识的部分，判断何时股票的运动正常已经包括了那部分的内容，这里就不重复了。 正确地感悟股票运动何时正常是最难学的，这也是炒股成功最关键的技巧之一。随着经验的增加，你的悟性越来越好，对股票运动的判断力越来越强，你就能将每次入场的获胜概率从50%提高到60%，甚至70%，慢慢地你就成了炒股专家。就我对这行的了解及体验，没有三年的全职经验连门都入不了。你要准备“熬”。 # 成功的投资者所具有的共性 无论做什么，没有欲望是不可能成功的。缺少欲望，你会在碰到些小困难时就打退堂鼓。每个人都有或多或少的赌性，股市提供了满足赌性的场所，它给你日常烦闷的生活提供了调剂。问问你自己，是否也是因这些原因进入股市的？再问一个问题：为了买家里2000元的那台电视机，你跑了几家商场对比价格？找了多少材料？问过多少人？做了多少研究？昨天你花2 万元买了那只股票，你又做了多少研究，找了多少资料？你买股票下的功夫是买电视机的百分之几？必须指出：欲望必须由努力做基础，否则只是白日梦，白日梦不是欲望，是梦。 必须具备锲而不舍的精神.锲而不舍是句很容易说，但很难做到的话。记得美国前总统柯立芝有句名言：“这个世界充满聪明而失意的人，受过良好教育但成日感叹怀才不遇的人。„„他们有个共性，缺少锲而不舍的精神。”什么是锲而不舍的精神？它是在忍无可忍的时候，再忍下去的毅力！ 想从股市不断赚到钱，你必须有知识，有经验，你必须成为专家。五年过去了，回首往事，有时自己都为自己的韧性感到骄傲。我要读者们分享希尔先生在他的不朽名著《思考致富》中的一句话：“当财富来到的时候，它将来得如此急，如此快，使人奇怪在那艰难的岁月，这些财富都躲到哪里去了？”我的生活经验证明这句话确实无误。这句话和孟夫子的名言“天将降大任于斯人也，必先苦其心智，劳其筋骨，饿其体肤”有异曲同工之处。 要有“与股市斗，其乐无穷”的气派.所有成功的投资者对市场及其运作都有极大的兴趣，他们喜欢市场所提供的挑战，有强烈的欲望要战胜这一市场。吸引他们在这一市场搏斗的不是金钱，不是名誉，不是快速致富。金钱只是他们玩股票游戏成功后的奖品。对一般人而言，他们进市场的目的是为了赚钱，这一期望使他们在这行成功的概率变得很低。因为这一期望使他们难以维持冷静的观察力，他们没有耐性等待必然的结果。中国的老话叫“猪油蒙了心”。利弗莫尔曾指出：一位成功的炒手必须如一位成功的商人，正确地预见未来的需求，适时进货，耐心地等待盈利的时刻。 要甘于做孤独者。几乎所有成功的投资者都是孤独者。他们必须是孤独者！因为他们常要做和大众不同事。为了与众不同所以做和大众相反的事是极其危险的。他们必须有合理的解释为何大众可能不对，同时预见采用相反思维所将引致的后果。这给他们与众不同时所需的信心。如果股市大多数人都看好某股票，他们都已按自己的能力入场，还有谁来买股使股市继续升得更高？反之，如果大多数股民不看好股市，他们都已经脱手出场，那么股市的继续下跌区间也已不大。你从小学习的那些讨人喜欢的性格，如听话、合群、不标新立异等等都成为炒股成功的障碍。 必须具有耐心和自制力。耐心和自制力都是听起来很简单但做起来很困难的事情。炒股是极其枯燥无味的工作。读者会嘲笑我的说法，说：“我炒过股，我觉得极其刺激好玩。”这是因为你把炒股当成消遣，没有将它当成严肃的工作。因为炒股是如此的单调乏味，新手们就喜欢不顾外在条件地在股市跳进跳出寻刺激。看过狮子是怎样捕猎的吗？它耐心地等待猎物，只有在时机及取胜机会都适合的时候，它才从草丛中跳出来。成功的炒手具有同样的特点，他绝不为炒股而炒股，他等待合适的时机，然后采取行动。等待时机也如种植花草。大家都知道春天是播种的时候，无论你多么喜欢花，在冬天把种子播入土的结果将是什么是很清楚的。你不能太早，也不能太迟，在正确的时间和环境做正确的事才有可能得到预想的效果。不幸的是，对业余炒手而言，往往不是没有耐心，也不是不知道危险，他们也知道春天是播种的时机，但问题是他们没有足够的知识和经验判定何时是春天！这需要漫长且艰难的学习过程，除了熬之外，没有其他的办法。当你经历了足够的升和跌，你的资金随升跌起伏，你的希望和恐惧随升跌而摆动，逐渐地，你的灵感就培养起来了。 必须有一套适合自己的炒股模式。炒股高手只有在股票的外在条件（包括基础分析、技术分析及股票大势）符合自己的作战计划时才采取行动。俗话说条条道路通罗马，这里的“罗马”就是累积财富，成为股票游戏的胜利者，而“道路”就是你自己的方法。什么道路并不重要，重要的是这条道路必须符合你的个性，你走起来轻松愉快，你有信心能走远路。在这基础上你才会对自己的方法有信心，最终不断完善自己的方法以取得最高效率。 必须具有超前的想象力及对未来的判断。这并不是说优秀的投资者具有一般人所不具备的第六感，而是他们有能力自繁杂的信息中理出头绪。大多数人注重于今天发生的一切并假设今天发生的一切会不断延续，但优秀的投资者会看得更远一步，预想在什么情况下今天的情形会停滞甚至产生逆转。他们并不较一般人聪明，但他们独立思考，不拘泥于成见。当他们看到改变的苗头，立即采取行动，绝不拖泥带水。 成功的投资者绝不幻想。一旦你把资金投入某只股票，按原来的预想，这只股票的运动不对，你会怎么办？一般人常常想象出各种理由把这一不正常的运动“合理化”。这种为避免割肉痛苦的合理化假设是极其致命的，这也是许多有一定经验的炒手最终不得不举手投降的主要原因。一位成功的投资者绝不让情感左右自己，有的话程度也很小。无论割肉认错是多么痛苦，他们绝不迟疑。他们明白，让这样的情况延续只会带来更大的痛苦和损失。业余炒手很少问自己一个问题：“假如我今天手边有钱，还会买这只股票吗？”就是问了，也会找成堆的理由来安慰自己：“隔壁老王说这只股票的下跌只是暂时的”，“卖出股票要手续费”等等。一句话，业余炒手想方设法不去止损。 要有应用知识的毅力。怎样才能减肥？答案其实只有四个字：少吃多动。减肥的知识是如此简单，减肥应是轻而易举的事吧？事实正好相反。美国有个统计，100 个人参加减肥训练，只有12 个人降低了体重，其中只有2 个人将体重降低持续一年以上，即2%的成功率。减肥失败的原因不是因为学习减肥多么困难，而是因为大多数人缺少每天应用这些知识的毅力。你很想吃一块蛋糕，但你知道这一块蛋糕下肚子，锻炼一天的效果就泡汤了，你忍得住吗？你定好计划，每天吃什么，锻炼多久，可你坚持了多久？炒股也是一样，任何对炒股有一定认识的人，都明白炒股所需的具体知识少的可怜。股票只有两条路可走，不是上就是下，影响股票升落的因素就是这么多，真正重要的因素。列出来占不满你的手指，甚至不识字的也可以在股市露一手。股票的引诱力也人所共知，你如果做的好，前景**的光明。这样的行业，成功率甚至低过减肥！为什么？因为人们常常做不到自己知道该做的事情！人们都知道诚实是取信于人的不二法门，有多少人做到了？我欣赏王安先生话：“我可能没有把我知道的全部告诉你，但告诉你的，全部是真的。一位成功的投资者，他应十分留意怎样将他的知识应用在炒股中，他不会因为应用这些知识的枯燥而忽略细节。在日常生活中，获得知识通常并不困难，困难在于用毅力应用这些知识。在炒股问题上，我是坚信“知易行难”之说的。 # 学习寻找临界点的过程其实就是学股的过程，当然其中还包括学习炒股的正确心态。坦率地讲，学找临界点的技巧还比较容易，培养心态才真正困难。华尔街将炒股的诀窍归纳成两句话：截短亏损，让利润奔跑！英文叫Cut loss short, let profit run! 意思是：一见股票情况不对，即刻止损，把它缩得越短越好！一旦有了利润，就必须让利润奔跑，从小利润跑成大利润。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>投资</tag>
        <tag>炒股</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书笔记【高效能人士的七个习惯】]]></title>
    <url>%2F2017%2F10%2F09%2Fbook_%E9%AB%98%E6%95%88%E8%83%BD%E4%BA%BA%E5%A3%AB%E7%9A%84%E4%B8%83%E4%B8%AA%E4%B9%A0%E6%83%AF%2F</url>
    <content type="text"><![CDATA[什么是习惯？ 本书中定义：“知识”、“技巧”与“意愿” 相互交织的结果。咋理解呢？ 知识： 做什么，为何做？ 技巧： 如何做？ 意愿： 想要做！ 七个习惯和个人感悟 积极主动（Be Positive）个人愿景的原则，即采取主动，为自己过去、现在及未来的行为负责，并依据原则及价值观，而非情绪或外在环境来下决定，创造改变，积极面对一切。 大家可能有时候想养成一个好习惯，但是对于根深蒂固的习惯，最好抱着长期作战的准备，我们大脑可不管你毅力有多强，它已经形成了对应的神经线路。比如说我要减肥，不吃猛锻炼，坚持几天，很快就弃疗了，不如改成每天坚持走路多少分钟，吃主食的时候，米饭少吃最后一两口，这里只是举个例子，想表达的意思是：积极主动的前提，我们需要找到科学而且适合自己的方法，而且在不断尝试中得到自己的认识，然后不断更新它。 举个典型的例子，很多人会提问这样的问题，怎么学好英语？帮我做个计划？我相信这部分人依赖心理很强，逃避倾向严重，遇到问题总是习惯性的寻找别人的帮忙，放弃了一次次自己解决问题的机会，即锻炼自己思维的机会，你多试试去行动就找到自己合适的方法了呗，折腾折腾啊！ 高效能人士：积极主动的人绝不浅尝辄止，他们知道要为自己的抉择负责、做出的选择总是基于原则和价值观，而不是基于情绪或受限于周围条件，积极的人是变化的催生者。 低效能人士：消极的人不愿违自己的抉择负责，他们总是觉得自己是受害者，受周围环境、自己的过去和他人的拖累，他们不把自己看作是生活的主人。 以终为始(Begin with the End in Mind)。自我领导的原则，个人、团队和组织在做任何计划时，均先拟出愿景和目标，并据此塑造未来，全心投注于自己最重视的原则、价值观、关系及目标之上。 高效能人士：他们对于任何项目，无论大小，也不管是个人还是团队的，都下决心完成。他们确立并献身于自己生活中最重要的原则、人际关系和目标。 低效能人士：不定行动目标，他们缺乏个人原价，没有目标，他们不思考生活的意义，也不愿制定使命宣言，他们的生活总是遵循社会留下的而不是自己选择的价值观。 要事第一(Put First Things First)。自我管理的原则，要事第一即实质的创造，是你的目标、愿景、价值观及要事的组织与实践，个人认为聚焦到创造性的活动上和分配时间到重要不紧急的事情（读书、写作、健身等）。 高效能人士：以要事为先的人总是按照事务的重要性来安排生活并付诸实践，无论情势如何，他们的生活总是遵循自己最珍视的原则。 低效能人士：不重要的事情先做，他们总是在应付各种危机，他们之所倚无法关注最重要的事务，是因为他们总是纠缠于周围环境、过去的事情或是是非非，他们陷入成堆的琐事，被紧迫的事务弄得团团转。 双赢思维(Think Win-Win)。人际领导的原则，双赢思维是一种基于互敬，寻求互惠的思考框架与心意，鼓励我们解决问题，并协助个人找到互惠的解决办法，是一种信息、力量、认可及报酬的分享。 高效能人士：能在交往中寻求双方获利、互相尊重。他们基于到处是机遇和富足的心态，基于“我们”而不是“我”，来进行思考，他们总是通过向感情账户存款来见了与他人的互信关系，多向身边的朋友或是长辈进行感情存储。 低效能人士：非赢即输，他们抱的是匮乏心态，把生活看作是一场零和游戏。他们不善于和他人沟通，总是从情感账户提款，结果是时时提防他人，陷入对抗的心理。 知己知彼(Seek First to Understand, Then to Be Understood)。 移情沟通的原则，当我们改变以回答的心态，而以了解对方的心态去聆听别人，便能开启真正的沟通，增进彼此关系，知彼需要仁慈心，解己需要勇气，能平衡两者，则可大幅提升沟通的效率。 高效能人士：当我们怀着理解对方的想法，而不是为了回答对方问题的心态去聆听，我们就能进行真正的沟通并建立友谊。 低效能人士：先寻求别人的理解，他们并未理解对方就先讲述自己的观点，完全机遇自己的经验货动机。他们不先对问题做出客观诊断就盲目开处方。 综合综效(Synergize)。 创造性合作的原则，统合综效是创造第三种选择，既非按照我的方式，亦非你的方式，而是第三种远胜过个人之见的办法，它是互相尊重的成果，使整体获得一加一大于二的成效。 不断更新(Sharpen the Saw)。平衡的自我更新原则，在四个基本生活方面（生理、社会、情感、心智）中，不断更新自己，这个习惯提升了其它六个习惯的实施效率。 高效能人士：在身体、社会／情感、智力、精神，不断更新自己。 低效能人士：没有自我更新、自我改善的规划。 简单理解就是不断反思，调整自己的规划。 成熟的哪三个阶段？ 在本书里面对成熟的定义：成熟模式图（Maturity Continuum), 具体分三个阶段 依赖期，你照顾我，你为我的得失成败负责。 独立期，我可以做到，我可以负责，我可以靠自己，我有权选择。 互赖期，我们可以做到，我们可以合作，我们可以融合彼此的智慧和能力，共创前程。 还有一点感触比较深 仅有事业成功只能算成功了一半，唯有兼顾事业、家庭、人际关系、个人成长等人生其它层面的和谐发展才是真正的成功。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>个人成长</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读书笔记【流星蝴蝶剑】]]></title>
    <url>%2F2017%2F10%2F05%2Fbook_%E6%B5%81%E6%98%9F%E8%9D%B4%E8%9D%B6%E5%89%91%2F</url>
    <content type="text"><![CDATA[一个人若有很深的心机，很大的阴谋，就绝不会做错事。 # 问题并不在有几成机会，而在于你能把握机会。若是真的能完全把握机会，一成机会也已足够。 # 人与人之间，好像总有种奇怪而愚昧的现象。他们总想以伤害别人来保护自己，他们伤害的却总是自己最亲近的！因为他们只能伤害到这些人，却忘了他们伤害到这些人的时候，同时也伤害了自己。所以他们受到的伤害也比别人更深。所以他们自己犯了错，自己痛恨自己时，就拼命想去伤害别人。 # 流星的光芒虽短促，但天上还有什么星能比它更灿烂，辉煌！当流星出现的时候，就算是永恒不变的星座，也夺不去它的光芒。蝴蝶的生命是脆弱的，甚至比最鲜艳的花还脆弱。可是它永远是活在春天里。 它美丽，它自由，它飞翔。它的生命虽短促却芬芳。只有剑，才比较接近永恒。一个剑客的光芒与生命，往往就在他手里握着的剑上。但剑若也有情，它的光芒是否也就会变得和流星一样短促。 # 男人就应该像个男人，说男人的话，做男人的事。 # 世上的确有很多的事都比死困难的多，痛苦的多！ # 尽量想法子让敌人低估你，但却绝不要低估了你的敌人。 # 寂寞本也有一种清淡的乐趣。 # 如果失去是苦，你还怕不怕付出，如果坠落是苦，你还要不要幸福，如果迷乱是苦，再开始还是结束，如果追求是苦，这是坚强还是执迷不悟 # 每个人都一定要为自己准备好一条最后的退路，你也许永远都不会走到那一步，但你必须要先有准备。 # 真正的朋友就和真正的仇敌一样，平时的确不容易看得出。 # 就因为不容易，所以才有趣，越不容易越有趣。 # 我只问你，你活过没有？ # 聪明的女人都知道对付男人有种最好的战略，那就是让男人觉得她软弱。 # 一个人要别人为他做事的时候，最好先问问自己能为对方做什么。 # 爱情本就是种最奇妙的情感，既没有人能了解，更没有人能控制，它不像友情，友情由累积而深厚，爱情却是突然发生的。 # 有时逃避只不过是种休息，让你有更多的勇气去面对人生。 # 黑暗无论多么长，光明迟早总是会来的。黑夜无论多么长，总有天亮的时候。 # 老伯永远不会等到要吃梨时候才种树，他早已撒下种子。每粒种子都随时可能开花结果。 # 你最好能令敌人低估自己的力量，否则你就最好不要有敌人。 # 有时一个人活着并不是为了享受欢乐，而是为了忍受痛苦，因为活着也只是种责任，谁也不能逃避。 # 就算天下最会说谎的人，眸子也不会说谎的。 # 控制男人的法子却有两种。一种是尽量让他们觉得你柔弱，让他们来照顾你、保护你，而且还要让他们以此为荣。还有一种就是尽量打击他们，尽量摧毁他们的尊严，要他们在你面前永远都抬不起头来。那么你只要对他们略加青睐，甚至只要对他们笑一笑，他们都会觉得很光荣，很感激。你若真的能让男人有这种感觉，他们就不惜为你做任何事了 # 因为你永远不知道自己什么时候才会走到那一步，那种情况就像是抽筋，随时随刻都会来的，让你根本没有防备的机会。 # 年轻人和老人之间，本就有着一段很大的距离，无论对什么事的看法，都很少会完全相同的！所以老人总觉得年轻人幼稚愚蠢，正如年轻人对老人的看法一样。年轻人虽然应该尊敬老人的思想和智慧。但尊敬并不是赞成！服从也不是！ # 一个男人若为了一个女人而沉迷不能自拔，这人就根本不值得重视，所以你也不必去同情他。 # 一个人遇到很大的困难和危险时，往往就会变得很多疑，对每个人都怀疑，觉得世上已没有一个他可以信任的人。这才是他的致命伤，那困难和危险也许并不能伤害到他，但‘怀疑’却往往会要了他的命。 # 有时候只要肯给别人一丝温情，就能令那人感激终生，有时你只要肯付出一丝温情，就能回收终生的欢愉。只可惜世人偏偏要将这一点温情吝惜，偏偏要用讥嘲和轻蔑去唤起别人的仇恨！ # 欲望和财富对一个人的作用，就好像醋对水一样，加了醋的水一定会变酸，有了欲望和财富，一个人也就很快就会变了. # 光阴似箭，日月如梭，绿鬓少年，忽已白头，人生一梦，梦醒便休，终日碌碌，所为何由？ # 一个人若懂得利用别人‘恶的’那一面，懂得利用别人的贪婪、虚荣、嫉妒、仇恨，他已经可以算是个很了不起的人。但你却比那些人更高一着，你还懂得利用别人‘善’的一面，还懂得利用别人的感激、同情和义气 # 惟一不同的是，男人喝了酒后，会想到各式各样的女人，很多不同的女人；女人喝了酒后，却往往只会想到一个男人。大多数时候她想到的是一个抛弃了她的男人。 # 有时逃避只不过是种休息，让你有更多的勇气去面对人生。所以你觉得太紧张时，若能逃避一下，也蛮不错的，但却千万不可逃避得太久，因为你所逃避的问题，绝不会因你逃避而解决的。你只能在逃避中休息，绝不能“死”在逃避里。 # 也许爱情就是这么回事。你若想享受爱情的甜蜜，就必须同时忍受它的烦恼和痛苦。 # 他忘了将人与人之间的情感算进去。也许走上大多数阴谋失败之路的人，都因为忘了将这一点算进去。人与人之间的情感本就是无法计算的，但却能决定一切，改变一切。正因为如此，所以人性永存，阴谋必败。 # 你想赚得多，就得花得多，只有会花钱的人才能赚得到更多的钱，这道理你不明白？ # 一个女人心目中的好丈夫，并不在乎他的年纪大小，只看他是不是懂得对妻子温柔体贴，是不是一个顶天立地的男子汉。 # 女人若想伤害一个人的时候，好像总能找出最恶毒的话来，这好像是她们天生的本事，正如响尾蛇生出来就是有毒的。 # 一个在不断追寻的人，内心挣扎得也许比钓钩上的鱼更痛苦，因为他虽然不断追寻，却一直不知道自己追寻的人究竟是什么。这样的追寻最容易令人厌倦 # 你若想抓住男人的心，就得随时随地注意自己的姿态。不但走路的样子要好看，坐着、站着、吃饭的时候，甚至连睡觉的时候都要尽量保持你最好看的姿态，就算你只不过是个妓女，也一定要男人觉得你很高贵，这样，男人才会死心塌地的喜欢你。]]></content>
      <categories>
        <category>读书笔记</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>武侠</tag>
        <tag>古龙</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[15个写出高效率的Email的技巧]]></title>
    <url>%2F2017%2F10%2F02%2Fhow_to_write_email%2F</url>
    <content type="text"><![CDATA[写邮件是我们日常工作经常做的一件事，如何写出一封高效率的Email并让人喜欢呢？在网上发现一个PDF，给出很多建议。 Tips: 确定您期望的结果，花点时间想清楚到底想让收件人知道什么 快速准确的回答，直接回答要点，用简短词语和关键字 邮件中清晰的叙述出好处 KISS原则， Keep it simple, stupid，邮件内容简短并且让人非常容易理解 基于事实陈述 保持自我介绍信息的简洁 注意邮件内容在网页和手机端的展示效果 避免过度赞美 回复邮件带有友好的话语，例如“Enjoy your weekend!” 个人签名中，个人信息清晰明了，方便联系 邮件布局清晰明了，让不同层次的人去抓他们关注的重点 邮件字体，加粗和标注颜色的字体都是重点信息，避免无效信息高亮显示 尽量减少问题，只提出最重要的问题，分解成细节，拒绝提出太宽泛的问题]]></content>
      <categories>
        <category>工作技能</category>
      </categories>
      <tags>
        <tag>工作技能</tag>
        <tag>Email</tag>
      </tags>
  </entry>
</search>
